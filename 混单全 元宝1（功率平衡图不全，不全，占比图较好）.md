import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.optimize import minimize
import random
from datetime import datetime, timedelta
import matplotlib.dates as mdates

plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False


# ==================== 基础储能模型类 ====================
class FESS:
    """飞轮储能系统模型"""

    def __init__(self, capacity_kWh=100, max_power_kW=200, efficiency=0.92):
        self.capacity_kWh = capacity_kWh
        self.max_power_kW = max_power_kW
        self.efficiency = efficiency
        self.soc = 0.5  # 初始SOC
        self.energy_kWh = capacity_kWh * self.soc

    def charge(self, power_kW, duration_h):
        """充电操作"""
        actual_power = min(power_kW, self.max_power_kW)
        energy_input = actual_power * duration_h * self.efficiency
        self.energy_kWh = min(self.energy_kWh + energy_input, self.capacity_kWh)
        self.soc = self.energy_kWh / self.capacity_kWh
        return actual_power

    def discharge(self, power_kW, duration_h):
        """放电操作"""
        available_power = min(power_kW, self.max_power_kW,
                              self.energy_kWh / duration_h * self.efficiency)
        energy_output = available_power * duration_h / self.efficiency
        self.energy_kWh = max(self.energy_kWh - energy_output, 0)
        self.soc = self.energy_kWh / self.capacity_kWh
        return available_power

    def get_status(self):
        return {
            'soc': self.soc,
            'energy_kWh': self.energy_kWh,
            'max_power': self.max_power_kW
        }


class BESS:
    """锂离子电池储能系统"""

    def __init__(self, capacity_kWh=500, max_power_kW=250, efficiency=0.95, degradation_rate=1e-5):
        self.capacity_kWh = capacity_kWh
        self.max_power_kW = max_power_kW
        self.efficiency = efficiency
        self.degradation_rate = degradation_rate
        self.soc = 0.5
        self.energy_kWh = capacity_kWh * self.soc
        self.cycle_count = 0

    def charge(self, power_kW, duration_h):
        actual_power = min(power_kW, self.max_power_kW)
        energy_input = actual_power * duration_h * self.efficiency
        self.energy_kWh = min(self.energy_kWh + energy_input, self.capacity_kWh)
        self.soc = self.energy_kWh / self.capacity_kWh
        # 简化的退化模型
        self.cycle_count += energy_input / self.capacity_kWh * 0.5
        self.capacity_kWh *= (1 - self.degradation_rate * actual_power * duration_h)
        return actual_power

    def discharge(self, power_kW, duration_h):
        available_power = min(power_kW, self.max_power_kW,
                              self.energy_kWh / duration_h * self.efficiency)
        energy_output = available_power * duration_h / self.efficiency
        self.energy_kWh = max(self.energy_kWh - energy_output, 0)
        self.soc = self.energy_kWh / self.capacity_kWh
        self.cycle_count += energy_output / self.capacity_kWh * 0.5
        return available_power

    def get_status(self):
        return {
            'soc': self.soc,
            'energy_kWh': self.energy_kWh,
            'max_power': self.max_power_kW,
            'degradation': 1 - self.capacity_kWh / 500
        }


class SC:
    """超级电容器储能"""

    def __init__(self, capacity_kWh=50, max_power_kW=300, efficiency=0.98):
        self.capacity_kWh = capacity_kWh
        self.max_power_kW = max_power_kW
        self.efficiency = efficiency
        self.soc = 0.5
        self.energy_kWh = capacity_kWh * self.soc

    def charge(self, power_kW, duration_h):
        actual_power = min(power_kW, self.max_power_kW)
        energy_input = actual_power * duration_h * self.efficiency
        self.energy_kWh = min(self.energy_kWh + energy_input, self.capacity_kWh)
        self.soc = self.energy_kWh / self.capacity_kWh
        return actual_power

    def discharge(self, power_kW, duration_h):
        available_power = min(power_kW, self.max_power_kW,
                              self.energy_kWh / duration_h * self.efficiency)
        energy_output = available_power * duration_h / self.efficiency
        self.energy_kWh = max(self.energy_kWh - energy_output, 0)
        self.soc = self.energy_kWh / self.capacity_kWh
        return available_power

    def get_status(self):
        return {
            'soc': self.soc,
            'energy_kWh': self.energy_kWh,
            'max_power': self.max_power_kW
        }


class SMES:
    """超导磁储能系统"""

    def __init__(self, capacity_kWh=30, max_power_kW=400, efficiency=0.85, standby_loss=0.01):
        self.capacity_kWh = capacity_kWh
        self.max_power_kW = max_power_kW
        self.efficiency = efficiency
        self.standby_loss = standby_loss
        self.soc = 0.5
        self.energy_kWh = capacity_kWh * self.soc

    def charge(self, power_kW, duration_h):
        actual_power = min(power_kW, self.max_power_kW)
        energy_input = actual_power * duration_h * self.efficiency
        self.energy_kWh = min(self.energy_kWh + energy_input, self.capacity_kWh)
        self.soc = self.energy_kWh / self.capacity_kWh
        return actual_power

    def discharge(self, power_kW, duration_h):
        available_power = min(power_kW, self.max_power_kW,
                              self.energy_kWh / duration_h * self.efficiency)
        energy_output = available_power * duration_h / self.efficiency
        self.energy_kWh = max(self.energy_kWh - energy_output, 0)
        self.soc = self.energy_kWh / self.capacity_kWh
        # 待机损耗
        self.energy_kWh *= (1 - self.standby_loss * duration_h)
        self.soc = self.energy_kWh / self.capacity_kWh
        return available_power

    def get_status(self):
        return {
            'soc': self.soc,
            'energy_kWh': self.energy_kWh,
            'max_power': self.max_power_kW
        }


class CAES:
    """压缩空气储能系统"""

    def __init__(self, capacity_kWh=1000, max_power_kW=500, efficiency=0.72, gas_price=0.35):
        self.capacity_kWh = capacity_kWh
        self.max_power_kW = max_power_kW
        self.efficiency = efficiency
        self.gas_price = gas_price  # 天然气价格 元/kWh
        self.soc = 0.5
        self.energy_kWh = capacity_kWh * self.soc
        self.operation_cost = 0

    def charge(self, power_kW, duration_h):
        actual_power = min(power_kW, self.max_power_kW)
        energy_input = actual_power * duration_h * self.efficiency
        self.energy_kWh = min(self.energy_kWh + energy_input, self.capacity_kWh)
        self.soc = self.energy_kWh / self.capacity_kWh
        return actual_power

    def discharge(self, power_kW, duration_h):
        available_power = min(power_kW, self.max_power_kW,
                              self.energy_kWh / duration_h * self.efficiency)
        energy_output = available_power * duration_h / self.efficiency

        # 燃料成本计算
        fuel_energy = energy_output * (1 - self.efficiency)
        fuel_cost = fuel_energy * self.gas_price
        self.operation_cost += fuel_cost

        self.energy_kWh = max(self.energy_kWh - energy_output, 0)
        self.soc = self.energy_kWh / self.capacity_kWh
        return available_power

    def get_status(self):
        return {
            'soc': self.soc,
            'energy_kWh': self.energy_kWh,
            'max_power': self.max_power_kW,
            'operation_cost': self.operation_cost
        }


# ==================== 混合储能系统优化控制器 ====================
class HybridEnergyStorageSystem:
    """混合储能系统优化控制器"""

    def __init__(self, time_step_min=5):
        self.time_step_h = time_step_min / 60
        self.storage_units = {
            'FESS': FESS(),
            'BESS': BESS(),
            'SC': SC(),
            'SMES': SMES(),
            'CAES': CAES()
        }

        # 权重系数 - 可根据实际需求调整
        self.weights = {
            'response_speed': 0.3,  # 响应速度权重
            'efficiency': 0.25,  # 效率权重
            'cost': 0.25,  # 成本权重
            'lifetime': 0.2  # 寿命权重
        }

        self.history = []
        self.power_imbalance_history = []

    def calculate_power_allocation(self, power_imbalance_kW):
        """基于分层随机MPC策略计算功率分配"""

        # 获取各储能单元状态
        status = {name: unit.get_status() for name, unit in self.storage_units.items()}

        # 定义优化目标函数
        def objective_function(allocations):
            # 分配比例归一化
            allocations = np.abs(allocations) / np.sum(np.abs(allocations))

            total_allocated_power = 0
            cost = 0
            response_penalty = 0

            for i, (name, unit) in enumerate(self.storage_units.items()):
                allocated_power = allocations[i] * power_imbalance_kW
                max_power = status[name]['max_power']

                # 功率限制惩罚
                if abs(allocated_power) > max_power:
                    cost += 1000 * (abs(allocated_power) - max_power) ** 2

                # 响应速度惩罚（基于储能类型）
                if name in ['SC', 'SMES']:  # 快速响应
                    response_penalty += 0.1 * abs(allocated_power)
                elif name in ['FESS']:  # 中等响应
                    response_penalty += 0.3 * abs(allocated_power)
                else:  # 慢速响应
                    response_penalty += 0.6 * abs(allocated_power)

                total_allocated_power += allocated_power

            # 目标1：功率平衡偏差最小
            balance_error = abs(total_allocated_power - power_imbalance_kW)

            # 目标2：SOC均衡度
            soc_variance = np.var([status[name]['soc'] for name in self.storage_units])

            return (self.weights['response_speed'] * response_penalty +
                    self.weights['efficiency'] * balance_error +
                    self.weights['cost'] * cost +
                    self.weights['lifetime'] * soc_variance)

        # 约束条件
        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(np.abs(x)) - 1}  # 分配比例和为1
        ]

        # 初始猜测（均匀分配）
        x0 = np.ones(5) / 5

        # 优化求解
        result = minimize(objective_function, x0, method='SLSQP',
                          constraints=constraints, bounds=[(0, 1)] * 5)

        if result.success:
            optimal_allocations = result.x / np.sum(result.x)
        else:
            # 如果优化失败，使用基于SOC的启发式分配
            optimal_allocations = self.heuristic_allocation(power_imbalance_kW, status)

        return optimal_allocations

    def heuristic_allocation(self, power_imbalance_kW, status):
        """启发式功率分配策略"""
        allocations = np.zeros(5)

        if power_imbalance_kW > 0:  # 需要放电
            # 优先使用快速响应储能
            fast_responders = ['SC', 'SMES', 'FESS']
            medium_responders = ['BESS']
            slow_responders = ['CAES']

            # 分配比例
            fast_ratio = 0.6
            medium_ratio = 0.3
            slow_ratio = 0.1

            fast_power = power_imbalance_kW * fast_ratio
            medium_power = power_imbalance_kW * medium_ratio
            slow_power = power_imbalance_kW * slow_ratio

            # 基于SOC和能力分配
            for i, name in enumerate(self.storage_units):
                if name in fast_responders:
                    allocations[i] = fast_power / len(fast_responders) * status[name]['soc']
                elif name in medium_responders:
                    allocations[i] = medium_power / len(medium_responders) * status[name]['soc']
                else:
                    allocations[i] = slow_power / len(slow_responders) * status[name]['soc']

        else:  # 需要充电
            # 充电策略：优先充电SOC较低的储能
            soc_values = [status[name]['soc'] for name in self.storage_units]
            min_soc = min(soc_values)

            for i, name in enumerate(self.storage_units):
                # SOC越低，分配越多充电功率
                allocations[i] = (1 - status[name]['soc']) / sum(1 - s for s in soc_values)

        return allocations / np.sum(allocations)

    def apply_pwm_control(self, target_power_kW, allocated_powers, duration_h):
        """应用PWM技术进行精确功率控制"""
        actual_powers = {}

        for (name, unit), allocated_power in zip(self.storage_units.items(), allocated_powers):
            if allocated_power > 0:  # 放电
                actual_power = unit.discharge(allocated_power, duration_h)
            else:  # 充电
                actual_power = -unit.charge(-allocated_power, duration_h)

            actual_powers[name] = actual_power

        return actual_powers

    def simulate_24h(self, power_imbalance_profile):
        """24小时仿真运行"""
        timestamps = [datetime(2024, 1, 1, 0, 0) + timedelta(minutes=5 * i)
                      for i in range(len(power_imbalance_profile))]

        for i, power_imbalance in enumerate(power_imbalance_profile):
            # 计算最优功率分配
            allocations = self.calculate_power_allocation(power_imbalance)

            # 应用PWM控制
            allocated_powers = allocations * power_imbalance
            actual_powers = self.apply_pwm_control(power_imbalance, allocated_powers, self.time_step_h)

            # 记录数据
            record = {
                'timestamp': timestamps[i],
                'power_imbalance_kW': power_imbalance,
                'total_allocated_kW': sum(actual_powers.values()),
                'balance_error': power_imbalance - sum(actual_powers.values())
            }

            # 各储能单元状态
            for name, power in actual_powers.items():
                record[f'{name}_power_kW'] = power
                record[f'{name}_soc'] = self.storage_units[name].get_status()['soc']

            self.history.append(record)

    def generate_power_profile(self, hours=24, resolution_min=5):
        """生成典型的微电网功率不平衡曲线"""
        n_points = int(hours * 60 / resolution_min)
        time_points = np.linspace(0, hours, n_points)

        # 基础负荷曲线（日周期）
        base_load = 1000 + 500 * np.sin(2 * np.pi * time_points / 24 - np.pi / 2)

        # 可再生能源波动（中高频）
        renewable_variation = (200 * np.sin(2 * np.pi * time_points / 2) +
                               100 * np.sin(2 * np.pi * time_points / 0.5) +
                               50 * np.random.normal(0, 1, n_points))

        # 随机扰动
        random_disturbance = 100 * np.random.normal(0, 0.5, n_points)

        total_imbalance = base_load + renewable_variation + random_disturbance
        return total_imbalance

    def plot_results(self):
        """绘制完整的分析图表"""
        df = pd.DataFrame(self.history)
        df.set_index('timestamp', inplace=True)

        fig, axes = plt.subplots(3, 2, figsize=(15, 12))
        fig.suptitle('混合储能系统24小时运行仿真结果', fontsize=16, fontweight='bold')

        # 1. 功率平衡效果图
        ax1 = axes[0, 0]
        ax1.plot(df.index, df['power_imbalance_kW'], 'b-', linewidth=2, label='待平衡功率')
        ax1.plot(df.index, df['total_allocated_kW'], 'r--', linewidth=2, label='储能总出力')
        ax1.fill_between(df.index, df['power_imbalance_kW'], df['total_allocated_kW'],
                         alpha=0.3, color='gray', label='平衡误差')
        ax1.set_ylabel('功率 (kW)')
        ax1.set_title('功率平衡效果图')
        ax1.legend()
        ax1.grid(True, alpha=0.3)

        # 2. 平衡误差图
        ax2 = axes[0, 1]
        ax2.plot(df.index, df['balance_error'], 'g-', linewidth=1)
        ax2.fill_between(df.index, 0, df['balance_error'], alpha=0.3, color='green')
        ax2.set_ylabel('平衡误差 (kW)')
        ax2.set_title('功率平衡误差')
        ax2.grid(True, alpha=0.3)

        # 3. SOC变化图
        ax3 = axes[1, 0]
        for name in self.storage_units:
            ax3.plot(df.index, df[f'{name}_soc'], label=name, linewidth=2)
        ax3.set_ylabel('SOC (%)')
        ax3.set_title('各储能单元SOC变化')
        ax3.legend()
        ax3.grid(True, alpha=0.3)

        # 4. 功率分配占比图
        ax4 = axes[1, 1]
        power_columns = [f'{name}_power_kW' for name in self.storage_units]
        power_data = df[power_columns].abs().values.T
        ax4.stackplot(df.index, power_data, labels=[name for name in self.storage_units])
        ax4.set_ylabel('功率分配 (kW)')
        ax4.set_title('功率分配占比变化')
        ax4.legend()
        ax4.grid(True, alpha=0.3)

        # 5. 能量变化图
        ax5 = axes[2, 0]
        # 计算累计能量变化（简化）
        time_h = np.array([i * self.time_step_h for i in range(len(df))])
        for name in self.storage_units:
            energy = np.cumsum(df[f'{name}_power_kW'].values * self.time_step_h)
            ax5.plot(df.index, energy, label=name, linewidth=2)
        ax5.set_ylabel('累计能量 (kWh)')
        ax5.set_title('各储能单元能量变化')
        ax5.legend()
        ax5.grid(True, alpha=0.3)

        # 6. 分配比例统计
        ax6 = axes[2, 1]
        total_power = df[power_columns].abs().sum(axis=1)
        allocation_ratios = {}
        for name in self.storage_units:
            allocation_ratios[name] = (df[f'{name}_power_kW'].abs().sum() /
                                       total_power.sum() * 100)

        colors = plt.cm.Set3(np.linspace(0, 1, len(allocation_ratios)))
        ax6.pie(allocation_ratios.values(), labels=allocation_ratios.keys(),
                autopct='%1.1f%%', colors=colors)
        ax6.set_title('总功率分配比例')

        plt.tight_layout()
        plt.show()

        # 打印统计信息
        print("\n=== 仿真结果统计 ===")
        print(f"平均平衡误差: {df['balance_error'].abs().mean():.2f} kW")
        print(f"最大平衡误差: {df['balance_error'].abs().max():.2f} kW")
        print(f"误差标准差: {df['balance_error'].std():.2f} kW")

        for name in self.storage_units:
            avg_soc = df[f'{name}_soc'].mean() * 100
            print(f"{name}平均SOC: {avg_soc:.1f}%")


# ==================== 主程序执行 ====================
if __name__ == "__main__":
    # 创建混合储能系统
    hess = HybridEnergyStorageSystem(time_step_min=5)

    # 生成24小时功率不平衡曲线
    print("生成功率不平衡曲线...")
    power_profile = hess.generate_power_profile(hours=24, resolution_min=5)

    # 运行24小时仿真
    print("开始24小时仿真...")
    hess.simulate_24h(power_profile)

    # 绘制结果
    print("生成分析图表...")
    hess.plot_results()

    print("仿真完成！")
