import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.signal import butter, filtfilt, savgol_filter, find_peaks

plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False


# ==================== 1. 各储能系统类（保持原样） ====================

class CAESSystem:
    def __init__(self, M_air_max=1000, M_air_min=100, P_max=100):
        self.M_air_max = M_air_max
        self.M_air_min = M_air_min
        self.P_max = P_max
        self.M_air_current = (M_air_max + M_air_min) / 2
        self.history = []
        self.eta = 0.85
        self.soc_history = []

    def step(self, P_cmd, dt=1):
        P_act = np.clip(P_cmd, -self.P_max, self.P_max)
        m_change = P_act * dt / (self.eta * 3600)
        M_air_next = self.M_air_current + m_change

        if M_air_next > self.M_air_max:
            M_air_next = self.M_air_max
            P_act = 0
        elif M_air_next < self.M_air_min:
            M_air_next = self.M_air_min
            P_act = 0

        self.M_air_current = M_air_next
        soc = (self.M_air_current - self.M_air_min) / (self.M_air_max - self.M_air_min)
        self.soc_history.append(soc)
        self.history.append(P_act)
        return P_act

    def get_soc(self):
        return (self.M_air_current - self.M_air_min) / (self.M_air_max - self.M_air_min)


class SupercapacitorSystem:
    def __init__(self, capacitance=3000, max_voltage=2.7, min_voltage=1.0, P_max=50):
        self.capacitance = capacitance
        self.max_voltage = max_voltage
        self.min_voltage = min_voltage
        self.P_max = P_max
        self.voltage = max_voltage
        self.history = []
        self.R_esr = 0.01
        self.soc_history = []

    def step(self, P_cmd, dt=1):
        P_act = np.clip(P_cmd, -self.P_max, self.P_max)

        if self.voltage > 0:
            I = P_act / self.voltage
        else:
            I = 0

        self.voltage -= I * self.R_esr * dt
        self.voltage = np.clip(self.voltage, self.min_voltage, self.max_voltage)

        soc = (self.voltage - self.min_voltage) / (self.max_voltage - self.min_voltage)
        self.soc_history.append(soc)
        self.history.append(P_act)
        return P_act

    def get_soc(self):
        return (self.voltage - self.min_voltage) / (self.max_voltage - self.min_voltage)


class FlywheelSystem:
    def __init__(self, max_energy=1e6, efficiency=0.9, P_max=30):
        self.max_energy = max_energy
        self.efficiency = efficiency
        self.P_max = P_max
        self.energy = max_energy / 2
        self.history = []
        self.soc_history = []

    def step(self, P_cmd, dt=1):
        P_act = np.clip(P_cmd, -self.P_max, self.P_max)

        if P_act > 0:  # 放电
            energy_out = P_act * dt / self.efficiency
        else:  # 充电
            energy_out = P_act * dt * self.efficiency

        self.energy -= energy_out
        self.energy = np.clip(self.energy, 0, self.max_energy)

        soc = self.energy / self.max_energy
        self.soc_history.append(soc)
        self.history.append(P_act)
        return P_act

    def get_soc(self):
        return self.energy / self.max_energy


class SMESSystem:
    def __init__(self, inductance=100, max_current=1000, P_max=40):
        self.inductance = inductance
        self.max_current = max_current
        self.P_max = P_max
        self.current = max_current / 2
        self.history = []
        self.soc_history = []

    def step(self, P_cmd, dt=1):
        P_act = np.clip(P_cmd, -self.P_max, self.P_max)

        if self.current > 0:
            di = P_act * dt / (self.inductance * self.current)
        else:
            di = 0

        self.current += di
        self.current = np.clip(self.current, 0, self.max_current)

        soc = self.current / self.max_current
        self.soc_history.append(soc)
        self.history.append(P_act)
        return P_act

    def get_soc(self):
        return self.current / self.max_current


class BESSSystem:
    def __init__(self, capacity=2000, max_power=80):
        self.capacity = capacity  # Wh
        self.max_power = max_power
        self.soc = 0.5
        self.history = []
        self.soc_history = []

    def step(self, P_cmd, dt=1):
        P_act = np.clip(P_cmd, -self.max_power, self.max_power)
        delta_energy = P_act * dt / 3600  # Wh
        self.soc -= delta_energy / self.capacity
        self.soc = np.clip(self.soc, 0, 1)

        self.soc_history.append(self.soc)
        self.history.append(P_act)
        return P_act

    def get_soc(self):
        return self.soc


# ==================== 2. 优化后的混合储能系统控制器 ====================

class OptimizedHybridEnergyStorageSystem:
    def __init__(self):
        # 初始化各储能单元
        self.caes = CAESSystem(P_max=80)
        self.sc = SupercapacitorSystem(P_max=50)
        self.fw = FlywheelSystem(P_max=40)
        self.smes = SMESSystem(P_max=40)
        self.bess = BESSSystem(max_power=60)

        self.storages = [self.caes, self.sc, self.fw, self.smes, self.bess]

        # 定义快速储能和慢速储能
        self.fast_storages = [self.sc, self.fw, self.smes]  # 快速储能（响应快）
        self.slow_storages = [self.caes, self.bess]  # 慢速储能（响应慢）

        # 历史记录
        self.power_history = []
        self.fast_power_history = []
        self.slow_power_history = []
        self.balance_history = []
        self.soc_history = []
        self.time_history = []
        self.demand_history = []
        self.high_freq_history = []

        # 控制参数
        self.cutoff_freq = 0.1  # 中高频分界频率
        self.smoothing_window = 10  # 平滑窗口大小
        self.soc_target = 0.5
        self.alpha = 0.1  # 快速储能权重系数

        # 性能指标
        self.fast_power_error_history = []

    def extract_high_frequency(self, signal, cutoff_freq=0.1, fs=1):
        """提取高频分量"""
        if len(signal) < 20:
            # 信号太短，使用简单高通滤波
            window_size = min(5, len(signal))
            low_freq = np.convolve(signal, np.ones(window_size) / window_size, mode='same')
            high_freq = signal - low_freq
            return high_freq

        try:
            # 使用巴特沃斯高通滤波器
            nyq = 0.5 * fs
            normal_cutoff = cutoff_freq / nyq
            b, a = butter(2, normal_cutoff, btype='high', analog=False)
            high_freq = filtfilt(b, a, signal)
            return high_freq
        except:
            # 滤波失败，使用简单方法
            window_size = min(5, len(signal))
            low_freq = np.convolve(signal, np.ones(window_size) / window_size, mode='same')
            high_freq = signal - low_freq
            return high_freq

    def extract_mid_high_frequency(self, signal, cutoff_low=0.05, cutoff_high=0.2, fs=1):
        """提取中高频分量"""
        if len(signal) < 30:
            # 信号太短，使用简化方法
            return self.extract_high_frequency(signal, cutoff_low, fs)

        try:
            # 使用带通滤波器提取中高频分量
            nyq = 0.5 * fs
            low = cutoff_low / nyq
            high = cutoff_high / nyq
            b, a = butter(2, [low, high], btype='band')
            mid_high_freq = filtfilt(b, a, signal)
            return mid_high_freq
        except:
            return self.extract_high_frequency(signal, cutoff_low, fs)

    def adaptive_allocate_power(self, P_demand, high_freq_component, fast_socs, slow_socs):
        """自适应功率分配策略"""
        # 目标：最小化快速储能出力与中高频功率的偏差

        # 1. 首先将中高频分量分配给快速储能
        fast_allocations = np.zeros(3)  # 三个快速储能

        # 根据SOC和响应速度分配高频分量
        # 响应速度权重（超级电容最快，飞轮次之，SMES最慢）
        response_weights = np.array([0.4, 0.35, 0.25])

        # SOC均衡权重（SOC高的多放电，SOC低的多充电）
        soc_deviations = np.array([abs(soc - 0.5) for soc in fast_socs])
        soc_weights = 1.0 + soc_deviations

        # 综合权重
        fast_weights = response_weights * soc_weights
        fast_weights = fast_weights / np.sum(fast_weights)

        # 分配高频分量给快速储能
        fast_total = high_freq_component
        fast_allocations = fast_total * fast_weights

        # 2. 低频分量（总需求减去快速储能出力）分配给慢速储能
        slow_total = P_demand - fast_total

        # 慢速储能分配
        slow_allocations = np.zeros(2)  # 两个慢速储能

        # 慢速储能权重（基于SOC和功率能力）
        slow_response_weights = np.array([0.6, 0.4])  # CAES权重高，BESS权重低
        slow_soc_deviations = np.array([abs(soc - 0.5) for soc in slow_socs])
        slow_soc_weights = 1.0 + slow_soc_deviations

        slow_weights = slow_response_weights * slow_soc_weights
        slow_weights = slow_weights / np.sum(slow_weights)

        slow_allocations = slow_total * slow_weights

        # 3. 组合所有分配
        allocations = np.zeros(5)
        allocations[0] = slow_allocations[0]  # CAES
        allocations[4] = slow_allocations[1]  # BESS
        allocations[1] = fast_allocations[0]  # 超级电容
        allocations[2] = fast_allocations[1]  # 飞轮
        allocations[3] = fast_allocations[2]  # SMES

        return allocations

    def calculate_fast_power_error(self, fast_power_total, high_freq_target):
        """计算快速储能出力与中高频目标的偏差"""
        return fast_power_total - high_freq_target

    def feedback_adjustment(self, error, current_socs, fast_storage_indices):
        """反馈调整机制，根据偏差调整分配"""
        adjustment = np.zeros(5)

        if abs(error) > 0.1:  # 如果偏差较大才调整
            # 将偏差按照快速储能的容量和SOC分配
            fast_capacities = np.array([50, 40, 40])  # 快速储能的最大功率

            # 根据SOC状态调整分配权重
            soc_factors = np.array([1.0 - abs(soc - 0.5) for soc in current_socs[fast_storage_indices]])

            # 计算调整权重
            adjust_weights = fast_capacities * soc_factors
            adjust_weights = adjust_weights / np.sum(adjust_weights)

            # 生成调整量
            adjust_values = -error * adjust_weights  # 负号表示减小偏差

            # 应用调整量
            for i, idx in enumerate(fast_storage_indices):
                adjustment[idx] = adjust_values[i]

        return adjustment

    def step(self, P_demand, t, demand_series=None):
        """执行一步协同控制"""
        # 1. 提取中高频分量
        if demand_series is not None and len(demand_series) > 20:
            # 使用最近一段历史数据
            window_size = min(50, len(demand_series))
            recent_demand = demand_series[-window_size:]

            # 提取中高频分量
            high_freq_component = self.extract_high_frequency(recent_demand, self.cutoff_freq)

            if len(high_freq_component) > 0:
                current_high_freq = high_freq_component[-1]
            else:
                current_high_freq = 0
        else:
            # 信号太短，使用简单估计
            current_high_freq = P_demand * 0.3  # 简单估计30%为高频分量

        # 记录高频分量
        self.high_freq_history.append(current_high_freq)

        # 2. 获取各储能SOC状态
        fast_socs = [storage.get_soc() for storage in self.fast_storages]
        slow_socs = [storage.get_soc() for storage in self.slow_storages]
        all_socs = fast_socs + slow_socs

        # 3. 自适应功率分配
        allocations = self.adaptive_allocate_power(P_demand, current_high_freq, fast_socs, slow_socs)

        # 4. 执行功率分配
        total_output = 0
        fast_power_total = 0
        slow_power_total = 0

        for i, (storage, P_alloc) in enumerate(zip(self.storages, allocations)):
            # 考虑功率限制
            if hasattr(storage, 'P_max'):
                P_max = storage.P_max
            elif hasattr(storage, 'max_power'):
                P_max = storage.max_power
            else:
                P_max = 100

            P_alloc = np.clip(P_alloc, -P_max, P_max)

            # 执行功率指令
            P_out = storage.step(P_alloc)
            total_output += P_out

            # 分类统计
            if i in [1, 2, 3]:  # 快速储能
                fast_power_total += P_out
            else:  # 慢速储能
                slow_power_total += P_out

        # 5. 计算快速储能出力与中高频目标的偏差
        fast_power_error = self.calculate_fast_power_error(fast_power_total, current_high_freq)
        self.fast_power_error_history.append(fast_power_error)

        # 6. 反馈调整（如果需要）
        if abs(fast_power_error) > 5:  # 偏差较大时进行调整
            fast_indices = [1, 2, 3]  # 快速储能索引
            adjustment = self.feedback_adjustment(fast_power_error, all_socs, fast_indices)

            # 应用调整（在下一个时间步生效）
            # 这里简化处理，直接在当前步调整
            for i, (storage, adj) in enumerate(zip(self.storages, adjustment)):
                if hasattr(storage, 'P_max'):
                    P_max = storage.P_max
                else:
                    P_max = storage.max_power

                # 获取当前功率
                current_power = storage.history[-1] if storage.history else 0

                # 应用调整
                adjusted_power = current_power + adj
                adjusted_power = np.clip(adjusted_power, -P_max, P_max)

                # 更新输出（这里简化，实际应该重新计算）
                if i in [1, 2, 3]:  # 快速储能
                    fast_power_total += (adjusted_power - current_power)
                else:
                    slow_power_total += (adjusted_power - current_power)

                total_output += (adjusted_power - current_power)

        # 7. 计算总平衡误差
        balance_error = P_demand - total_output

        # 8. 记录数据
        self.power_history.append(total_output)
        self.fast_power_history.append(fast_power_total)
        self.slow_power_history.append(slow_power_total)
        self.balance_history.append(balance_error)
        self.soc_history.append(all_socs)
        self.time_history.append(t)
        self.demand_history.append(P_demand)

        return total_output, fast_power_error, balance_error

    def run_simulation(self, steps=300, demand_signal=None):
        """运行仿真"""
        if demand_signal is None:
            # 生成测试需求信号
            t = np.linspace(0, 15, steps)
            demand_signal = (
                    60 * np.sin(0.3 * t) +  # 低频
                    40 * np.sin(2 * t) +  # 中频
                    30 * np.sin(5 * t) +  # 中高频
                    25 * np.sin(10 * t) +  # 高频
                    20 * np.random.randn(steps)  # 随机噪声
            )

        # 重置历史记录
        self.__init__()

        for t in range(steps):
            P_demand = demand_signal[t]
            self.step(P_demand, t, demand_signal[:t + 1])

    def plot_optimized_results(self):
        """绘制优化结果图"""
        fig, axes = plt.subplots(4, 2, figsize=(18, 14))

        time_array = np.array(self.time_history)
        power_array = np.array(self.power_history)
        demand_array = np.array(self.demand_history)
        fast_power_array = np.array(self.fast_power_history)
        slow_power_array = np.array(self.slow_power_history)
        high_freq_array = np.array(self.high_freq_history)
        error_array = np.array(self.fast_power_error_history)

        # 1. 总功率对比
        ax1 = axes[0, 0]
        ax1.plot(time_array, demand_array, 'b-', alpha=0.7, label='需求功率', linewidth=1.5)
        ax1.plot(time_array, power_array, 'r-', label='实际出力', linewidth=1.5)
        ax1.fill_between(time_array, demand_array, power_array, alpha=0.2, color='gray')
        ax1.set_ylabel('功率 (kW)')
        ax1.set_title('总功率对比')
        ax1.legend()
        ax1.grid(True, alpha=0.3)

        # 2. 功率分解对比
        ax2 = axes[0, 1]
        ax2.plot(time_array, high_freq_array, 'g-', label='中高频分量', linewidth=1.5)
        ax2.plot(time_array, fast_power_array, 'r--', label='快速储能出力', linewidth=1.5)
        ax2.plot(time_array, slow_power_array, 'b--', label='慢速储能出力', linewidth=1.5)
        ax2.fill_between(time_array, high_freq_array, fast_power_array, alpha=0.2, color='orange')
        ax2.set_ylabel('功率 (kW)')
        ax2.set_title('功率分解与分配')
        ax2.legend()
        ax2.grid(True, alpha=0.3)

        # 3. 快速储能出力偏差
        ax3 = axes[1, 0]
        ax3.plot(time_array, error_array, 'm-', label='快速储能出力偏差', linewidth=1.5)
        ax3.axhline(y=0, color='black', linestyle='--', alpha=0.5)
        ax3.fill_between(time_array, error_array, 0, where=(error_array >= 0),
                         alpha=0.3, color='red', label='正偏差')
        ax3.fill_between(time_array, error_array, 0, where=(error_array < 0),
                         alpha=0.3, color='blue', label='负偏差')
        ax3.set_ylabel('偏差 (kW)')
        ax3.set_title('快速储能出力与中高频目标的偏差')
        ax3.legend()
        ax3.grid(True, alpha=0.3)

        # 4. 功率平衡误差
        ax4 = axes[1, 1]
        balance_array = np.array(self.balance_history)
        ax4.plot(time_array, balance_array, 'g-', label='总平衡误差', linewidth=1.5)
        ax4.axhline(y=0, color='black', linestyle='--', alpha=0.5)
        ax4.set_ylabel('误差 (kW)')
        ax4.set_title('总功率平衡误差')
        ax4.legend()
        ax4.grid(True, alpha=0.3)

        # 5. 各储能SOC变化
        ax5 = axes[2, 0]
        soc_array = np.array(self.soc_history)
        labels = ['CAES', '超级电容', '飞轮', 'SMES', '锂电']
        colors = ['blue', 'green', 'red', 'purple', 'orange']

        for i in range(soc_array.shape[1]):
            ax5.plot(time_array, soc_array[:, i], color=colors[i],
                     label=labels[i], linewidth=1.5)

        ax5.axhline(y=0.2, color='gray', linestyle='--', alpha=0.5)
        ax5.axhline(y=0.8, color='gray', linestyle='--', alpha=0.5)
        ax5.set_ylabel('SOC')
        ax5.set_title('各储能单元SOC变化')
        ax5.legend(loc='upper right')
        ax5.grid(True, alpha=0.3)

        # 6. 功率平滑效果
        ax6 = axes[2, 1]
        if len(power_array) > 10:
            window_size = min(10, len(power_array))
            smoothed = np.convolve(power_array, np.ones(window_size) / window_size, mode='same')

            ax6.plot(time_array, power_array, 'b-', alpha=0.4, label='原始出力', linewidth=1)
            ax6.plot(time_array, smoothed, 'r-', label=f'移动平均 (窗宽={window_size})', linewidth=2)
            ax6.axhline(y=np.mean(power_array), color='orange', linestyle='--',
                        label='平均值', linewidth=2)
            ax6.set_ylabel('功率 (kW)')
            ax6.set_title('功率平滑效果')
            ax6.legend()
            ax6.grid(True, alpha=0.3)

        # 7. 性能统计
        ax7 = axes[3, 0]
        ax7.axis('off')

        # 计算性能指标
        fast_error_mean = np.mean(np.abs(error_array))
        fast_error_std = np.std(error_array)
        balance_error_mean = np.mean(np.abs(balance_array))
        balance_error_std = np.std(balance_array)
        power_std = np.std(power_array)

        # 计算目标达成度
        target_achievement = 1.0 - (fast_error_mean / (np.mean(np.abs(high_freq_array)) + 1e-10))

        stats_text = (
            f"=== 优化后性能统计 ===\n\n"
            f"主要目标指标:\n"
            f"快速储能偏差均值: {fast_error_mean:.3f} kW\n"
            f"快速储能偏差标准差: {fast_error_std:.3f} kW\n"
            f"目标达成度: {target_achievement * 100:.1f}%\n\n"
            f"系统总体指标:\n"
            f"总平衡误差均值: {balance_error_mean:.3f} kW\n"
            f"总平衡误差标准差: {balance_error_std:.3f} kW\n"
            f"出力标准差: {power_std:.3f} kW\n"
            f"出力变异系数: {power_std / (np.mean(np.abs(power_array)) + 1e-10):.3f}\n\n"
            f"储能SOC状态:\n"
        )

        if len(soc_array) > 0:
            for i, label in enumerate(labels):
                mean_soc = np.mean(soc_array[:, i])
                soc_std = np.std(soc_array[:, i])
                stats_text += f"  {label}: {mean_soc:.3f} ± {soc_std:.3f}\n"

        ax7.text(0.05, 0.95, stats_text, transform=ax7.transAxes,
                 fontsize=9, verticalalignment='top',
                 bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

        # 8. 功率频谱分析
        ax8 = axes[3, 1]
        if len(power_array) > 50:
            # 计算功率谱密度
            fft_result = np.fft.fft(power_array)
            freqs = np.fft.fftfreq(len(power_array))

            # 只取正频率部分
            idx = np.where(freqs > 0)
            freqs = freqs[idx]
            power_spectrum = np.abs(fft_result[idx])

            # 找到主要频率成分
            peaks, _ = find_peaks(power_spectrum, height=np.mean(power_spectrum))

            ax8.plot(freqs[:len(freqs) // 2], power_spectrum[:len(power_spectrum) // 2], 'b-', label='功率谱')
            if len(peaks) > 0:
                ax8.plot(freqs[peaks[:min(5, len(peaks))]], power_spectrum[peaks[:min(5, len(peaks))]],
                         'ro', label='主要频率')
            ax8.set_xlabel('频率 (Hz)')
            ax8.set_ylabel('功率谱密度')
            ax8.set_title('出力功率频谱分析')
            ax8.legend()
            ax8.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

        return {
            'fast_error_mean': fast_error_mean,
            'fast_error_std': fast_error_std,
            'balance_error_mean': balance_error_mean,
            'balance_error_std': balance_error_std,
            'power_std': power_std,
            'target_achievement': target_achievement
        }

    def print_performance_summary(self):
        """打印性能摘要"""
        time_array = np.array(self.time_history)
        fast_error_array = np.array(self.fast_power_error_history)
        balance_array = np.array(self.balance_history)
        power_array = np.array(self.power_history)
        high_freq_array = np.array(self.high_freq_history)

        # 计算关键指标
        fast_error_mean = np.mean(np.abs(fast_error_array))
        fast_error_std = np.std(fast_error_array)
        balance_error_mean = np.mean(np.abs(balance_array))
        balance_error_std = np.std(balance_array)
        power_std = np.std(power_array)
        target_achievement = 1.0 - (fast_error_mean / (np.mean(np.abs(high_freq_array)) + 1e-10))

        print("=" * 60)
        print("混合储能系统性能优化结果")
        print("=" * 60)
        print(f"主要目标（最小化快速储能出力与中高频功率偏差）：")
        print(f"  - 快速储能偏差均值: {fast_error_mean:.3f} kW")
        print(f"  - 快速储能偏差标准差: {fast_error_std:.3f} kW")
        print(f"  - 目标达成度: {target_achievement * 100:.1f}%")
        print()
        print(f"系统总体性能：")
        print(f"  - 总平衡误差均值: {balance_error_mean:.3f} kW")
        print(f"  - 总平衡误差标准差: {balance_error_std:.3f} kW")
        print(f"  - 出力功率标准差: {power_std:.3f} kW")
        print(f"  - 出力波动减少: {(1 - power_std / np.std(self.demand_history)) * 100:.1f}%")
        print()
        print(f"储能状态：")

        soc_array = np.array(self.soc_history)
        labels = ['CAES', '超级电容', '飞轮', 'SMES', '锂电']

        for i, label in enumerate(labels):
            if i < soc_array.shape[1]:
                mean_soc = np.mean(soc_array[:, i])
                soc_range = f"{np.min(soc_array[:, i]):.3f}-{np.max(soc_array[:, i]):.3f}"
                print(f"  - {label}: 均值={mean_soc:.3f}, 范围={soc_range}")

        print("=" * 60)


# ==================== 3. 主程序 ====================

if __name__ == "__main__":
    print("=== 混合储能系统优化仿真 ===")
    print("目标：最小化快速储能出力与中高频功率之间的偏差")
    print("=" * 60)

    # 创建优化后的混合储能系统
    hess = OptimizedHybridEnergyStorageSystem()

    # 生成测试需求信号
    steps = 300
    t = np.linspace(0, 15, steps)

    # 多频率成分测试信号
    demand_signal = (
            60 * np.sin(0.3 * t) +  # 低频成分
            40 * np.sin(1.5 * t) +  # 中低频
            35 * np.sin(3.0 * t) +  # 中频
            30 * np.sin(6.0 * t) +  # 中高频
            25 * np.sin(12.0 * t) +  # 高频
            20 * np.random.randn(steps) * (0.5 + 0.2 * np.sin(0.5 * t)) +  # 时变噪声
            15 * np.sign(np.sin(2.5 * t))  # 脉冲成分
    )

    # 运行仿真
    print("正在运行仿真...")
    hess.run_simulation(steps=steps, demand_signal=demand_signal)

    # 绘制结果
    print("正在生成图表...")
    stats = hess.plot_optimized_results()

    # 打印性能摘要
    hess.print_performance_summary()

    # 输出详细性能指标
    print("\n详细性能指标：")
    print(f"1. 快速储能偏差性能：")
    print(f"   均值绝对值: {stats['fast_error_mean']:.3f} kW")
    print(f"   标准差: {stats['fast_error_std']:.3f} kW")
    print(f"2. 系统总体性能：")
    print(f"   总平衡误差均值: {stats['balance_error_mean']:.3f} kW")
    print(f"   总平衡误差标准差: {stats['balance_error_std']:.3f} kW")
    print(f"   出力功率标准差: {stats['power_std']:.3f} kW")
    print(f"3. 控制效果评估：")
    print(f"   目标达成度: {stats['target_achievement'] * 100:.1f}%")
