import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.optimize import minimize
import cvxpy as cp
import random
from datetime import datetime, timedelta
import matplotlib as mpl

# 设置中文字体
plt.rcParams['font.sans-serif'] = ['SimHei', 'Arial Unicode MS', 'DejaVu Sans']
plt.rcParams['axes.unicode_minus'] = False

# 配置类
class EnergyStorageConfig:
    def __init__(self):
        # 时间参数
        self.time_horizon = 24  # 24小时
        self.time_step = 1  # 1小时步长
        self.time_points = int(self.time_horizon / self.time_step)
        
        # 系统参数
        self.total_load = 12.0  # 总负荷12MW
        self.base_power_variation = 1.5  # 基础功率波动
        
        # 储能设备技术参数
        self.energy_storages = {
            'BESS': {  # 电池储能
                'power_rating': 4.0,  # MW
                'energy_capacity': 12.0,  # MWh
                'efficiency': 0.92,  # 充放电效率
                'response_time': 0.1,  # 秒
                'cycle_life': 5000,  # 循环次数
                'cost_per_kwh': 650,  # 元/kWh
                'cost_per_kw': 1200,  # 元/kW
                'soc_min': 0.2,
                'soc_max': 0.9,
                'soc_initial': 0.5
            },
            'CAES': {  # 压缩空气储能
                'power_rating': 6.0,  # MW
                'energy_capacity': 18.0,  # MWh
                'efficiency': 0.7,  # 充放电效率
                'response_time': 2.0,  # 分钟
                'cycle_life': 20000,  # 循环次数
                'cost_per_kwh': 450,  # 元/kWh
                'cost_per_kw': 800,  # 元/kW
                'fuel_cost': 3.5,  # 天然气价格 元/m³
                'soc_min': 0.3,
                'soc_max': 0.95,
                'soc_initial': 0.6
            },
            'FESS': {  # 飞轮储能
                'power_rating': 3.0,  # MW
                'energy_capacity': 0.5,  # MWh
                'efficiency': 0.95,  # 充放电效率
                'response_time': 0.05,  # 秒
                'cycle_life': 100000,  # 循环次数
                'cost_per_kwh': 2000,  # 元/kWh
                'cost_per_kw': 1500,  # 元/kW
                'soc_min': 0.1,
                'soc_max': 0.9,
                'soc_initial': 0.5
            },
            'SC': {  # 超级电容
                'power_rating': 2.0,  # MW
                'energy_capacity': 0.3,  # MWh
                'efficiency': 0.98,  # 充放电效率
                'response_time': 0.01,  # 秒
                'cycle_life': 1000000,  # 循环次数
                'cost_per_kwh': 3500,  # 元/kWh
                'cost_per_kw': 2000,  # 元/kW
                'soc_min': 0.2,
                'soc_max': 0.9,
                'soc_initial': 0.5
            },
            'SMES': {  # 超导磁储能
                'power_rating': 1.0,  # MW
                'energy_capacity': 0.2,  # MWh
                'efficiency': 0.97,  # 充放电效率
                'response_time': 0.02,  # 秒
                'cycle_life': 50000,  # 循环次数
                'cost_per_kwh': 10000,  # 元/kWh
                'cost_per_kw': 5000,  # 元/kW
                'soc_min': 0.3,
                'soc_max': 0.9,
                'soc_initial': 0.5
            }
        }
        
        # 价格参数
        self.electricity_price = {
            'valley': 0.21,  # 谷电价 0:00-8:00
            'flat': 0.65,   # 平电价 8:00-12:00, 14:00-18:00, 22:00-24:00
            'peak': 1.12,   # 峰电价 12:00-14:00, 18:00-22:00
        }
        
        # MPC参数
        self.prediction_horizon = 6  # 预测时域6小时
        self.control_horizon = 3  # 控制时域3小时
        self.random_samples = 20  # 随机采样次数
        
        # 权重参数
        self.power_balance_weight = 1.0
        self.soc_weight = 0.1
        self.cost_weight = 0.01
        self.wear_weight = 0.001
        
        # PWM参数
        self.pwm_frequency = 1000  # Hz
        self.pwm_period = 1.0 / self.pwm_frequency
        self.pwm_resolution = 100  # 占空比分辨率

# 储能设备基类
class EnergyStorageDevice:
    def __init__(self, name, config):
        self.name = name
        self.config = config
        self.params = self.config.energy_storages[name]
        
        # 状态变量
        self.soc = self.params['soc_initial']  # 当前SOC
        self.power = 0.0  # 当前功率，正值表示放电，负值表示充电
        self.energy = self.soc * self.params['energy_capacity']  # 当前能量
        self.cycles = 0  # 循环次数
        self.operating_cost = 0.0  # 运行成本
        
    def update_state(self, power_setpoint, time_step, pwm_duty_cycle=1.0):
        """更新储能设备状态，考虑PWM调节"""
        # PWM调节实际出力
        effective_power = power_setpoint * pwm_duty_cycle
        
        # 考虑设备响应时间
        if self.params['response_time'] > 0.1:  # 慢响应设备
            time_constant = min(time_step, 1.0)  # 最大1小时
            actual_power = self.power + (effective_power - self.power) * time_constant
        else:  # 快响应设备
            actual_power = effective_power
        
        # 功率限制
        max_power = self.params['power_rating']
        if actual_power > 0:  # 放电
            actual_power = min(actual_power, max_power)
            # 考虑放电效率
            actual_power *= self.params['efficiency']
        else:  # 充电
            actual_power = max(actual_power, -max_power)
            # 考虑充电效率
            actual_power /= self.params['efficiency']
        
        # 能量更新
        energy_change = actual_power * time_step
        new_energy = self.energy - energy_change  # 放电减少能量
        
        # SOC计算
        new_soc = new_energy / self.params['energy_capacity']
        
        # SOC边界检查
        if new_soc < self.params['soc_min']:
            new_soc = self.params['soc_min']
            new_energy = new_soc * self.params['energy_capacity']
        elif new_soc > self.params['soc_max']:
            new_soc = self.params['soc_max']
            new_energy = new_soc * self.params['energy_capacity']
        
        # 更新状态
        self.power = actual_power
        self.energy = new_energy
        self.soc = new_soc
        
        # 更新循环计数（粗略估计）
        if power_setpoint != 0:
            self.cycles += abs(power_setpoint) * time_step / (2 * self.params['energy_capacity'])
        
        # 计算运行成本
        self._calculate_operating_cost(power_setpoint, time_step)
        
        return actual_power
    
    def _calculate_operating_cost(self, power, time_step):
        """计算运行成本"""
        if power > 0:  # 放电
            # 能量成本
            energy_cost = power * time_step * 0.1  # 简化成本模型
            # 设备折旧
            depreciation = (self.params['cost_per_kwh'] * self.params['energy_capacity'] * 1000 / 
                          self.params['cycle_life']) * abs(power) * time_step / (2 * self.params['energy_capacity'])
            self.operating_cost += energy_cost + depreciation
        else:  # 充电
            # 充电成本
            charging_cost = abs(power) * time_step * 0.08
            self.operating_cost += charging_cost
    
    def get_available_power(self, direction='both'):
        """获取可用功率"""
        if direction == 'discharge':
            max_discharge = min(self.params['power_rating'], 
                               (self.energy - self.params['soc_min'] * self.params['energy_capacity']) / self.time_step)
            return max_discharge
        elif direction == 'charge':
            max_charge = min(self.params['power_rating'],
                            (self.params['soc_max'] * self.params['energy_capacity'] - self.energy) / self.time_step)
            return max_charge
        else:
            return self.params['power_rating']
    
    def get_cost_coefficient(self, time_of_day):
        """获取成本系数"""
        base_cost = 0.0
        if self.name == 'CAES':
            # CAES考虑燃料成本
            gas_price = self.params['fuel_cost']
            base_cost = gas_price * 0.1  # 简化模型
        else:
            # 其他设备主要考虑折旧
            base_cost = (self.params['cost_per_kwh'] * 1000 / self.params['cycle_life']) * 0.5
        
        # 考虑电价
        if 0 <= time_of_day < 8:
            electricity_cost = self.config.electricity_price['valley']
        elif 8 <= time_of_day < 12 or 14 <= time_of_day < 18 or 22 <= time_of_day <= 24:
            electricity_cost = self.config.electricity_price['flat']
        else:
            electricity_cost = self.config.electricity_price['peak']
        
        return base_cost + electricity_cost * 0.1

# 混合储能系统
class HybridEnergyStorageSystem:
    def __init__(self, config):
        self.config = config
        self.devices = {}
        
        # 初始化所有储能设备
        for device_name in config.energy_storages.keys():
            self.devices[device_name] = EnergyStorageDevice(device_name, config)
        
        # 状态记录
        self.power_history = {name: [] for name in self.devices.keys()}
        self.soc_history = {name: [] for name in self.devices.keys()}
        self.total_power_history = []
        self.load_history = []
        self.imbalance_history = []
        self.cost_history = []
        
    def calculate_pwm_duty_cycle(self, power_setpoint, device_name):
        """计算PWM占空比"""
        device = self.devices[device_name]
        
        # 根据设备响应特性计算占空比
        if device_name in ['FESS', 'SC', 'SMES']:  # 快速响应设备
            # 高频PWM调节
            base_duty = 0.8
            power_ratio = abs(power_setpoint) / device.params['power_rating']
            duty_cycle = base_duty + 0.2 * power_ratio
        else:  # 慢速响应设备
            # 低频PWM调节
            base_duty = 0.9
            power_ratio = abs(power_setpoint) / device.params['power_rating']
            duty_cycle = base_duty + 0.1 * power_ratio
        
        return min(max(duty_cycle, 0.1), 1.0)
    
    def update_all_devices(self, power_allocations, time_step, time_of_day):
        """更新所有设备状态"""
        total_power = 0.0
        total_cost = 0.0
        
        for device_name, power_setpoint in power_allocations.items():
            if device_name in self.devices:
                # 计算PWM占空比
                duty_cycle = self.calculate_pwm_duty_cycle(power_setpoint, device_name)
                
                # 更新设备状态
                actual_power = self.devices[device_name].update_state(power_setpoint, time_step, duty_cycle)
                
                # 记录历史
                self.power_history[device_name].append(actual_power)
                self.soc_history[device_name].append(self.devices[device_name].soc)
                
                total_power += actual_power
                total_cost += self.devices[device_name].operating_cost
        
        return total_power, total_cost
    
    def record_system_state(self, load, total_power, imbalance):
        """记录系统状态"""
        self.total_power_history.append(total_power)
        self.load_history.append(load)
        self.imbalance_history.append(imbalance)
        
        # 计算总成本
        total_cost = sum(device.operating_cost for device in self.devices.values())
        self.cost_history.append(total_cost)

# 分层随机MPC控制器
class HierarchicalRandomMPC:
    def __init__(self, config, hess):
        self.config = config
        self.hess = hess
        
        # 优化参数
        self.upper_level_horizon = 24  # 上层优化时域
        self.lower_level_horizon = config.prediction_horizon
        
    def upper_level_optimization(self, load_forecast, time_of_day):
        """上层优化：经济调度"""
        # 获取设备状态
        device_states = {}
        for name, device in self.hess.devices.items():
            device_states[name] = {
                'soc': device.soc,
                'available_power': device.get_available_power(),
                'cost_coeff': device.get_cost_coefficient(time_of_day)
            }
        
        # 优化目标：最小化总成本
        def objective(x):
            total_cost = 0.0
            idx = 0
            for name in self.hess.devices.keys():
                power = x[idx]
                cost_coeff = device_states[name]['cost_coeff']
                total_cost += abs(power) * cost_coeff
                idx += 1
            return total_cost
        
        # 约束条件
        constraints = []
        x0 = []
        bounds = []
        
        idx = 0
        for name, device in self.hess.devices.items():
            # 初始猜测值
            x0.append(0.0)
            
            # 功率边界
            max_power = device.params['power_rating']
            bounds.append((-max_power, max_power))
            
            idx += 1
        
        # 功率平衡约束
        def power_balance_constraint(x):
            total_power = 0.0
            idx = 0
            for name in self.hess.devices.keys():
                total_power += x[idx]
                idx += 1
            return total_power - load_forecast[0]  # 与第一个预测点平衡
        
        constraints.append({'type': 'eq', 'fun': power_balance_constraint})
        
        # SOC约束
        def soc_constraint(x):
            soc_violation = 0.0
            idx = 0
            for name, device in self.hess.devices.items():
                power = x[idx]
                time_step = 1.0
                energy_change = power * time_step
                new_energy = device.energy - energy_change
                new_soc = new_energy / device.params['energy_capacity']
                
                # SOC越界惩罚
                if new_soc < device.params['soc_min']:
                    soc_violation += (device.params['soc_min'] - new_soc) * 100
                elif new_soc > device.params['soc_max']:
                    soc_violation += (new_soc - device.params['soc_max']) * 100
                
                idx += 1
            return soc_violation
        
        constraints.append({'type': 'ineq', 'fun': lambda x: -soc_constraint(x)})
        
        # 求解优化问题
        result = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=constraints)
        
        if result.success:
            # 提取优化结果
            optimized_powers = {}
            idx = 0
            for name in self.hess.devices.keys():
                optimized_powers[name] = result.x[idx]
                idx += 1
            return optimized_powers
        else:
            # 如果优化失败，使用启发式规则
            return self.heuristic_dispatch(load_forecast[0], device_states)
    
    def lower_level_optimization(self, power_reference, time_of_day):
        """下层优化：实时功率平衡"""
        # 随机MPC：生成多个随机场景，选择最优
        best_solution = None
        best_cost = float('inf')
        
        for sample in range(self.config.random_samples):
            # 随机生成功率分配
            random_allocation = {}
            remaining_power = power_reference
            
            device_names = list(self.hess.devices.keys())
            random.shuffle(device_names)
            
            for i, name in enumerate(device_names):
                device = self.hess.devices[name]
                
                if i == len(device_names) - 1:
                    # 最后一个设备承担剩余功率
                    random_allocation[name] = remaining_power
                else:
                    # 随机分配功率
                    max_power = min(device.params['power_rating'], abs(remaining_power))
                    if remaining_power >= 0:
                        # 放电
                        allocated = random.uniform(0, max_power)
                        random_allocation[name] = allocated
                        remaining_power -= allocated
                    else:
                        # 充电
                        allocated = random.uniform(-max_power, 0)
                        random_allocation[name] = allocated
                        remaining_power -= allocated
            
            # 评估随机分配
            cost = self.evaluate_allocation(random_allocation, time_of_day)
            
            if cost < best_cost:
                best_cost = cost
                best_solution = random_allocation.copy()
        
        return best_solution
    
    def evaluate_allocation(self, allocation, time_of_day):
        """评估功率分配方案"""
        total_cost = 0.0
        
        for name, power in allocation.items():
            device = self.hess.devices[name]
            
            # 功率成本
            cost_coeff = device.get_cost_coefficient(time_of_day)
            power_cost = abs(power) * cost_coeff
            
            # SOC惩罚
            time_step = 1.0
            energy_change = power * time_step
            new_energy = device.energy - energy_change
            new_soc = new_energy / device.params['energy_capacity']
            
            soc_penalty = 0.0
            if new_soc < device.params['soc_min']:
                soc_penalty = (device.params['soc_min'] - new_soc) * 1000
            elif new_soc > device.params['soc_max']:
                soc_penalty = (new_soc - device.params['soc_max']) * 1000
            
            total_cost += power_cost + soc_penalty
        
        return total_cost
    
    def heuristic_dispatch(self, power_needed, device_states):
        """启发式功率分配"""
        allocation = {}
        remaining_power = power_needed
        
        # 按响应速度排序：快速设备优先
        fast_devices = ['SMES', 'SC', 'FESS']
        slow_devices = ['BESS', 'CAES']
        
        # 先分配快速设备
        for name in fast_devices:
            if name in self.hess.devices and abs(remaining_power) > 0.01:
                device = self.hess.devices[name]
                max_power = min(device.params['power_rating'], abs(remaining_power))
                
                if remaining_power > 0:  # 需要放电
                    allocated = min(max_power, remaining_power)
                    allocation[name] = allocated
                    remaining_power -= allocated
                else:  # 需要充电
                    allocated = -min(max_power, abs(remaining_power))
                    allocation[name] = allocated
                    remaining_power -= allocated
            else:
                allocation[name] = 0.0
        
        # 再分配慢速设备
        for name in slow_devices:
            if name in self.hess.devices and abs(remaining_power) > 0.01:
                device = self.hess.devices[name]
                max_power = min(device.params['power_rating'], abs(remaining_power))
                
                if remaining_power > 0:  # 需要放电
                    allocated = min(max_power, remaining_power)
                    allocation[name] = allocated
                    remaining_power -= allocated
                else:  # 需要充电
                    allocated = -min(max_power, abs(remaining_power))
                    allocation[name] = allocated
                    remaining_power -= allocated
            else:
                allocation[name] = 0.0
        
        return allocation
    
    def optimize(self, load_forecast, time_of_day):
        """执行分层优化"""
        # 上层优化：经济调度
        economic_allocation = self.upper_level_optimization(load_forecast, time_of_day)
        
        # 下层优化：实时平衡
        power_reference = sum(economic_allocation.values())
        realtime_allocation = self.lower_level_optimization(power_reference, time_of_day)
        
        return realtime_allocation

# 主仿真类
class MicrogridSimulation:
    def __init__(self, config):
        self.config = config
        self.hess = HybridEnergyStorageSystem(config)
        self.mpc = HierarchicalRandomMPC(config, self.hess)
        
        # 生成负荷数据
        self.load_profile = self.generate_load_profile()
        
        # 生成需要平衡的功率（中高频波动）
        self.imbalance_power = self.generate_imbalance_power()
        
    def generate_load_profile(self):
        """生成24小时负荷曲线"""
        load = np.zeros(self.config.time_points)
        
        # 典型日负荷曲线
        for t in range(self.config.time_points):
            hour = t % 24
            if 0 <= hour < 6:  # 凌晨低谷
                base_load = 8.0
            elif 6 <= hour < 8:  # 早高峰前
                base_load = 10.0
            elif 8 <= hour < 12:  # 上午高峰
                base_load = 11.5
            elif 12 <= hour < 14:  # 午间
                base_load = 10.5
            elif 14 <= hour < 18:  # 下午高峰
                base_load = 12.0
            elif 18 <= hour < 22:  # 晚高峰
                base_load = 11.0
            else:  # 夜间
                base_load = 9.0
            
            # 添加随机波动
            fluctuation = np.random.normal(0, 0.5)
            load[t] = base_load + fluctuation
        
        return load
    
    def generate_imbalance_power(self):
        """生成需要平衡的中高频功率波动"""
        imbalance = np.zeros(self.config.time_points)
        
        for t in range(self.config.time_points):
            # 基础波动
            base_imbalance = np.sin(2 * np.pi * t / 4) * 0.8  # 4小时周期
            
            # 随机高频波动
            high_freq = np.sin(2 * np.pi * t / 0.5) * 0.3  # 0.5小时周期
            
            # 随机噪声
            noise = np.random.normal(0, 0.2)
            
            imbalance[t] = base_imbalance + high_freq + noise
        
        return imbalance
    
    def run_simulation(self):
        """运行24小时仿真"""
        print("开始运行混合储能系统仿真...")
        print(f"仿真时长: {self.config.time_horizon}小时")
        print(f"时间步长: {self.config.time_step}小时")
        print(f"储能设备数量: {len(self.hess.devices)}")
        print("=" * 50)
        
        for t in range(self.config.time_points):
            current_hour = t * self.config.time_step
            
            # 当前负荷和需平衡功率
            current_load = self.load_profile[t]
            current_imbalance = self.imbalance_power[t]
            
            # 负荷预测（简单预测，实际应用中应使用更复杂的预测模型）
            prediction_start = t
            prediction_end = min(t + self.config.prediction_horizon, self.config.time_points)
            load_forecast = self.load_profile[prediction_start:prediction_end]
            
            if len(load_forecast) < self.config.prediction_horizon:
                # 如果预测长度不足，用最后一个值填充
                load_forecast = np.append(load_forecast, 
                                         np.ones(self.config.prediction_horizon - len(load_forecast)) * load_forecast[-1])
            
            # MPC优化
            power_allocation = self.mpc.optimize(load_forecast, current_hour)
            
            # 更新储能系统
            total_power, _ = self.hess.update_all_devices(power_allocation, self.config.time_step, current_hour)
            
            # 计算功率偏差
            power_imbalance = current_imbalance - total_power
            
            # 记录系统状态
            self.hess.record_system_state(current_load, total_power, power_imbalance)
            
            # 打印进度
            if t % 4 == 0:  # 每4小时打印一次
                print(f"时间: {current_hour:02d}:00")
                print(f"  负荷: {current_load:.2f} MW, 需平衡功率: {current_imbalance:.2f} MW")
                print(f"  储能总出力: {total_power:.2f} MW, 功率偏差: {power_imbalance:.2f} MW")
                print(f"  设备出力: ", end="")
                for name, device in self.hess.devices.items():
                    print(f"{name}: {device.power:.2f} MW ", end="")
                print()
                print(f"  设备SOC: ", end="")
                for name, device in self.hess.devices.items():
                    print(f"{name}: {device.soc:.2%} ", end="")
                print()
                print("-" * 50)
        
        print("仿真完成!")
        self.print_summary()
    
    def print_summary(self):
        """打印仿真结果摘要"""
        print("\n" + "=" * 50)
        print("仿真结果摘要")
        print("=" * 50)
        
        # 功率平衡统计
        total_imbalance = np.array(self.hess.imbalance_history)
        mean_imbalance = np.mean(np.abs(total_imbalance))
        max_imbalance = np.max(np.abs(total_imbalance))
        
        print(f"功率平衡统计:")
        print(f"  平均绝对偏差: {mean_imbalance:.4f} MW")
        print(f"  最大绝对偏差: {max_imbalance:.4f} MW")
        print(f"  标准差: {np.std(total_imbalance):.4f} MW")
        
        # 设备使用统计
        print(f"\n设备使用统计:")
        for name, device in self.hess.devices.items():
            power_data = np.array(self.hess.power_history[name])
            avg_power = np.mean(np.abs(power_data))
            max_power = np.max(np.abs(power_data))
            soc_data = np.array(self.hess.soc_history[name])
            avg_soc = np.mean(soc_data)
            
            print(f"  {name}:")
            print(f"    平均功率: {avg_power:.3f} MW, 最大功率: {max_power:.3f} MW")
            print(f"    平均SOC: {avg_soc:.2%}, 最终SOC: {device.soc:.2%}")
            print(f"    运行成本: {device.operating_cost:.2f} 元")
        
        # 总成本统计
        total_cost = sum(device.operating_cost for device in self.hess.devices.values())
        print(f"\n总运行成本: {total_cost:.2f} 元")
        
        # 功率分配比例
        print(f"\n功率分配比例:")
        total_power_abs = 0
        for name in self.hess.devices.keys():
            power_data = np.array(self.hess.power_history[name])
            total_power_abs += np.sum(np.abs(power_data))
        
        for name in self.hess.devices.keys():
            power_data = np.array(self.hess.power_history[name])
            power_contribution = np.sum(np.abs(power_data))
            proportion = power_contribution / total_power_abs if total_power_abs > 0 else 0
            print(f"  {name}: {proportion:.2%}")
    
    def plot_results(self):
        """绘制仿真结果图"""
        fig, axes = plt.subplots(4, 1, figsize=(15, 12))
        time_hours = np.arange(self.config.time_points) * self.config.time_step
        
        # 1. 功率平衡图
        ax1 = axes[0]
        ax1.plot(time_hours, self.load_profile, 'b-', linewidth=2, label='负荷功率')
        ax1.plot(time_hours, self.hess.total_power_history, 'r-', linewidth=2, label='储能总出力')
        ax1.plot(time_hours, self.imbalance_power, 'g--', linewidth=1.5, alpha=0.7, label='需平衡功率')
        ax1.fill_between(time_hours, 0, self.imbalance_power, alpha=0.3, color='green')
        ax1.set_xlabel('时间 (小时)')
        ax1.set_ylabel('功率 (MW)')
        ax1.set_title('系统功率平衡图')
        ax1.legend(loc='upper right')
        ax1.grid(True, alpha=0.3)
        
        # 2. SOC变化图
        ax2 = axes[1]
        colors = ['red', 'blue', 'green', 'orange', 'purple']
        for idx, (name, soc_data) in enumerate(self.hess.soc_history.items()):
            ax2.plot(time_hours, soc_data, color=colors[idx], linewidth=1.5, label=name)
        ax2.set_xlabel('时间 (小时)')
        ax2.set_ylabel('SOC (%)')
        ax2.set_title('储能设备SOC变化图')
        ax2.legend(loc='upper right')
        ax2.grid(True, alpha=0.3)
        ax2.set_ylim(0, 1)
        
        # 3. 功率分配占比变化图
        ax3 = axes[2]
        # 计算每个时刻的功率分配比例
        power_data = np.array([self.hess.power_history[name] for name in self.hess.devices.keys()])
        
        # 计算累计功率
        cumulative_power = np.zeros_like(time_hours, dtype=float)
        for idx, name in enumerate(self.hess.devices.keys()):
            device_power = np.array(self.hess.power_history[name])
            device_power_abs = np.abs(device_power)
            total_power_abs = np.sum(np.abs(power_data), axis=0)
            
            # 避免除以零
            with np.errstate(divide='ignore', invalid='ignore'):
                proportion = np.where(total_power_abs > 0, device_power_abs / total_power_abs, 0)
            
            ax3.fill_between(time_hours, cumulative_power, cumulative_power + proportion, 
                            alpha=0.7, label=name)
            cumulative_power += proportion
        
        ax3.set_xlabel('时间 (小时)')
        ax3.set_ylabel('功率分配比例')
        ax3.set_title('储能设备功率分配占比变化图')
        ax3.legend(loc='upper right')
        ax3.set_ylim(0, 1)
        ax3.grid(True, alpha=0.3)
        
        # 4. 功率偏差图
        ax4 = axes[3]
        imbalance_array = np.array(self.hess.imbalance_history)
        ax4.plot(time_hours, imbalance_array, 'r-', linewidth=1.5)
        ax4.fill_between(time_hours, 0, imbalance_array, where=imbalance_array>=0, 
                        alpha=0.3, color='red', interpolate=True)
        ax4.fill_between(time_hours, 0, imbalance_array, where=imbalance_array<0, 
                        alpha=0.3, color='blue', interpolate=True)
        ax4.axhline(y=0, color='k', linestyle='-', linewidth=0.5)
        ax4.set_xlabel('时间 (小时)')
        ax4.set_ylabel('功率偏差 (MW)')
        ax4.set_title('功率平衡效果图 (储能总出力与需平衡功率的偏差)')
        ax4.grid(True, alpha=0.3)
        
        # 计算并显示平均偏差
        mean_imbalance = np.mean(np.abs(imbalance_array))
        max_imbalance = np.max(np.abs(imbalance_array))
        ax4.text(0.02, 0.95, f'平均绝对偏差: {mean_imbalance:.4f} MW\n最大绝对偏差: {max_imbalance:.4f} MW',
                transform=ax4.transAxes, verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
        
        plt.tight_layout()
        plt.show()
        
        # 5. 额外：各设备功率出力图
        fig2, axes2 = plt.subplots(len(self.hess.devices), 1, figsize=(15, 10))
        if len(self.hess.devices) == 1:
            axes2 = [axes2]
        
        for idx, (name, power_data) in enumerate(self.hess.power_history.items()):
            ax = axes2[idx]
            ax.plot(time_hours, power_data, color=colors[idx], linewidth=1.5)
            ax.fill_between(time_hours, 0, power_data, where=np.array(power_data)>=0, 
                          alpha=0.3, color=colors[idx])
            ax.fill_between(time_hours, 0, power_data, where=np.array(power_data)<0, 
                          alpha=0.3, color='blue')
            ax.axhline(y=0, color='k', linestyle='-', linewidth=0.5)
            ax.set_ylabel(f'{name}功率 (MW)')
            ax.set_title(f'{name}功率出力曲线')
            ax.grid(True, alpha=0.3)
            
            # 计算设备统计信息
            avg_power = np.mean(np.abs(power_data))
            max_power = np.max(np.abs(power_data))
            ax.text(0.02, 0.95, f'平均功率: {avg_power:.3f} MW\n最大功率: {max_power:.3f} MW',
                   transform=ax.transAxes, verticalalignment='top',
                   bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
        
        axes2[-1].set_xlabel('时间 (小时)')
        plt.tight_layout()
        plt.show()

# 主程序
def main():
    # 创建配置
    config = EnergyStorageConfig()
    
    # 创建微电网仿真
    microgrid = MicrogridSimulation(config)
    
    # 运行仿真
    microgrid.run_simulation()
    
    # 绘制结果
    microgrid.plot_results()
    
    # 保存数据到文件
    save_data_to_csv(microgrid)

def save_data_to_csv(microgrid):
    """保存仿真数据到CSV文件"""
    time_hours = np.arange(microgrid.config.time_points) * microgrid.config.time_step
    
    # 创建DataFrame
    data = {
        '时间(小时)': time_hours,
        '负荷功率(MW)': microgrid.load_profile,
        '需平衡功率(MW)': microgrid.imbalance_power,
        '储能总出力(MW)': microgrid.hess.total_power_history,
        '功率偏差(MW)': microgrid.hess.imbalance_history
    }
    
    # 添加各设备功率
    for name, power_data in microgrid.hess.power_history.items():
        data[f'{name}_功率(MW)'] = power_data
    
    # 添加各设备SOC
    for name, soc_data in microgrid.hess.soc_history.items():
        data[f'{name}_SOC'] = soc_data
    
    df = pd.DataFrame(data)
    
    # 保存到CSV
    df.to_csv('hybrid_energy_storage_results.csv', index=False, encoding='utf-8-sig')
    print(f"\n仿真数据已保存到: hybrid_energy_storage_results.csv")

if __name__ == "__main__":
    main()
