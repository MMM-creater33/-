# -*- coding: utf-8 -*-
"""
12MW园区级混合储能系统协同调度代码（修复版）
基于分层随机MPC策略 + PWM出力调节
目标：最小化储能总出力与待平衡功率的偏差，实现系统功率平滑
包含：FESS/BESS/SC/SMES/CAES五种储能单元，24小时仿真
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.optimize import linprog
import math
from datetime import datetime, timedelta

# ============================ 1. 全局参数配置 ============================
plt.rcParams['font.sans-serif'] = ['SimHei']  # 中文显示
plt.rcParams['axes.unicode_minus'] = False  # 负号显示
np.random.seed(42)  # 固定随机种子，保证结果可复现

# 系统基础参数
SYSTEM_CAPACITY = 12000  # 系统总容量 (kW)，12MW
SIMULATION_HOURS = 24  # 仿真时长 (小时)
TIME_STEP = 3600 / 60  # 时间步长 (秒)，1分钟/步
TOTAL_STEPS = int(SIMULATION_HOURS * 3600 / TIME_STEP)  # 总步数

# 储能单元容量分配占比（基于经济效益和响应特性优化）
# 慢速能量型：CAES(60%) + BESS(25%)；快速功率型：SC(8%) + FESS(5%) + SMES(2%)
CAPACITY_RATIO = {
    'CAES': 0.60,  # 压缩空气：大容量长时储能，成本低
    'BESS': 0.25,  # 锂电池：中短时能量时移，响应较快
    'SC': 0.08,  # 超级电容：高频波动平抑，寿命长
    'FESS': 0.05,  # 飞轮：中频响应，循环寿命长
    'SMES': 0.02  # 超导磁：极高频响应，精度高（成本限制占比最低）
}

# 各储能单元额定参数（基于12MW总容量计算）
STORAGE_PARAMS = {
    # 慢速能量型储能
    'CAES': {
        'rated_power': SYSTEM_CAPACITY * CAPACITY_RATIO['CAES'],  # 7200kW
        'max_energy': 7200 * 8,  # 57600kWh (8小时满功率放电)
        'min_energy': 5760,  # 最小储能（10%额定容量）
        'efficiency': 0.65,  # 往返效率
        'cost_per_kwh': 2750,  # 单位造价 (元/kWh)
        'response_time': 10  # 响应时间 (秒)
    },
    'BESS': {
        'rated_power': SYSTEM_CAPACITY * CAPACITY_RATIO['BESS'],  # 3000kW
        'max_energy': 3000 * 4,  # 12000kWh (4小时满功率放电)
        'min_energy': 1200,  # 最小储能（10%额定容量）
        'efficiency': 0.91,  # 往返效率
        'cost_per_kwh': 0.7,  # 单位造价 (元/Wh) → 700元/kWh
        'response_time': 1  # 响应时间 (秒)
    },
    # 快速功率型储能
    'SC': {
        'rated_power': SYSTEM_CAPACITY * CAPACITY_RATIO['SC'],  # 960kW
        'max_energy': 960 * 0.1,  # 96kWh (短时间大功率输出)
        'min_energy': 9.6,  # 最小储能（10%额定容量）
        'efficiency': 0.88,  # 往返效率
        'cost_per_kwh': 2000,  # 单位造价 (元/kWh)
        'response_time': 0.01  # 响应时间 (秒)
    },
    'FESS': {
        'rated_power': SYSTEM_CAPACITY * CAPACITY_RATIO['FESS'],  # 600kW
        'max_energy': 600 * 0.2,  # 120kWh
        'min_energy': 12,  # 最小储能（10%额定容量）
        'efficiency': 0.89,  # 往返效率
        'cost_per_kw': 10000,  # 单位功率造价 (元/kW)
        'response_time': 0.1  # 响应时间 (秒)
    },
    'SMES': {
        'rated_power': SYSTEM_CAPACITY * CAPACITY_RATIO['SMES'],  # 240kW
        'max_energy': 240 * 0.05,  # 12kWh
        'min_energy': 1.2,  # 最小储能（10%额定容量）
        'efficiency': 0.96,  # 往返效率（最高）
        'cost_per_kwh': 65000,  # 单位造价 (元/kWh)（最高）
        'response_time': 0.001  # 响应时间 (秒)（最快）
    }
}

# 南京冬季工商业电价（2026年1月数据，元/kWh）
ELECTRICITY_PRICE = {
    'valley': 0.21,  # 低谷：00:00-06:00, 11:00-13:00
    'flat': 0.62,  # 平段：06:00-11:00, 13:00-14:00, 22:00-24:00
    'peak': 1.12,  # 高峰：14:00-22:00
    'sharp_peak': 1.34  # 尖峰：18:00-20:00
}

# 天然气价格（南京冬季工商业，元/m³）
GAS_PRICE = 3.65

# PWM调节参数
PWM_FREQUENCY = 100  # PWM开关频率 (Hz)
PWM_DUTY_CYCLE = 0.5  # 基础占空比


# ============================ 2. 场景生成与不确定性建模 ============================
def generate_load_profile():
    """生成24小时园区负荷曲线（含不确定性波动）
    基础负荷 + 随机波动 + 周期性波动
    """
    time_hours = np.linspace(0, SIMULATION_HOURS, TOTAL_STEPS)
    base_load = np.zeros_like(time_hours)

    # 基础负荷模式（园区典型负荷曲线）
    for i, t in enumerate(time_hours):
        if 0 <= t < 6:  # 深夜低谷
            base_load[i] = SYSTEM_CAPACITY * 0.4
        elif 6 <= t < 8:  # 早高峰
            base_load[i] = SYSTEM_CAPACITY * 0.8
        elif 8 <= t < 11:  # 上午平段
            base_load[i] = SYSTEM_CAPACITY * 0.6
        elif 11 <= t < 13:  # 午间低谷
            base_load[i] = SYSTEM_CAPACITY * 0.5
        elif 13 <= t < 18:  # 下午平段
            base_load[i] = SYSTEM_CAPACITY * 0.7
        elif 18 <= t < 20:  # 晚高峰（尖峰）
            base_load[i] = SYSTEM_CAPACITY * 0.95
        else:  # 夜间平段
            base_load[i] = SYSTEM_CAPACITY * 0.55

    # 添加不确定性：10%的随机波动 + 5%的高频噪声
    random_fluctuation = np.random.normal(0, SYSTEM_CAPACITY * 0.1, TOTAL_STEPS)
    high_freq_noise = np.random.normal(0, SYSTEM_CAPACITY * 0.05, TOTAL_STEPS)
    load_curve = base_load + random_fluctuation + high_freq_noise

    # 确保负荷非负
    load_curve = np.maximum(load_curve, SYSTEM_CAPACITY * 0.3)
    return load_curve


def generate_generation_profile():
    """生成24小时电源出力曲线（假设为电网供电，含小幅波动）"""
    time_hours = np.linspace(0, SIMULATION_HOURS, TOTAL_STEPS)
    base_generation = SYSTEM_CAPACITY * 0.8  # 基础供电量（80%额定容量）

    # 添加小幅波动（电源侧不确定性）
    fluctuation = np.random.normal(0, SYSTEM_CAPACITY * 0.03, TOTAL_STEPS)
    generation_curve = base_generation + fluctuation

    return generation_curve


def calculate_unbalanced_power(generation, load):
    """计算待平衡功率（负荷 - 电源出力）"""
    return load - generation


# ============================ 3. 储能单元类定义 ============================
class CAES:
    """压缩空气储能（慢速能量型）"""

    def __init__(self, params):
        self.rated_power = params['rated_power']
        self.max_energy = params['max_energy']
        self.min_energy = params['min_energy']
        self.efficiency = params['efficiency']
        self.current_energy = (self.max_energy + self.min_energy) / 2  # 初始储能（50%）
        self.power_history = []  # 功率历史
        self.energy_history = []  # 能量历史
        self.soc_history = []  # SOC历史

    def calculate_soc(self):
        """计算荷电状态 (SOC)"""
        return (self.current_energy - self.min_energy) / (self.max_energy - self.min_energy)

    def pwm_control(self, target_power, duty_cycle):
        """PWM调节出力"""
        return target_power * duty_cycle

    def charge(self, power, time_step):
        """充电：吸收电能，转化为压缩空气势能"""
        power = min(power, self.rated_power)  # 不超过额定功率
        actual_power = self.pwm_control(power, PWM_DUTY_CYCLE)
        energy_absorbed = actual_power * time_step / 3600  # 转化为kWh
        self.current_energy += energy_absorbed * self.efficiency

        # 约束：不超过最大储能
        if self.current_energy > self.max_energy:
            self.current_energy = self.max_energy
            actual_power = 0

        return actual_power

    def discharge(self, power, time_step):
        """放电：释放压缩空气势能，转化为电能"""
        power = min(power, self.rated_power)  # 不超过额定功率
        actual_power = self.pwm_control(power, PWM_DUTY_CYCLE)
        energy_released = actual_power * time_step / 3600  # 转化为kWh
        self.current_energy -= energy_released / self.efficiency

        # 约束：不低于最小储能
        if self.current_energy < self.min_energy:
            self.current_energy = self.min_energy
            actual_power = 0

        return actual_power

    def step(self, target_power, time_step):
        """单步运行：根据目标功率充放电"""
        if target_power < 0:  # 负功率：充电（吸收多余电能）
            actual_power = self.charge(-target_power, time_step)
            actual_power = -actual_power  # 保持功率符号一致性
        else:  # 正功率：放电（补充不足电能）
            actual_power = self.discharge(target_power, time_step)

        # 记录历史数据
        self.power_history.append(actual_power)
        self.energy_history.append(self.current_energy)
        self.soc_history.append(self.calculate_soc())
        return actual_power


class BESS:
    """锂电池储能（中速能量型）"""

    def __init__(self, params):
        self.rated_power = params['rated_power']
        self.max_energy = params['max_energy']
        self.min_energy = params['min_energy']
        self.efficiency = params['efficiency']
        self.current_energy = (self.max_energy + self.min_energy) / 2  # 初始储能（50%）
        self.power_history = []
        self.energy_history = []
        self.soc_history = []

    def calculate_soc(self):
        return (self.current_energy - self.min_energy) / (self.max_energy - self.min_energy)

    def pwm_control(self, target_power, duty_cycle):
        return target_power * duty_cycle

    def charge(self, power, time_step):
        power = min(power, self.rated_power)
        actual_power = self.pwm_control(power, PWM_DUTY_CYCLE)
        energy_absorbed = actual_power * time_step / 3600
        self.current_energy += energy_absorbed * self.efficiency

        if self.current_energy > self.max_energy:
            self.current_energy = self.max_energy
            actual_power = 0

        return actual_power

    def discharge(self, power, time_step):
        power = min(power, self.rated_power)
        actual_power = self.pwm_control(power, PWM_DUTY_CYCLE)
        energy_released = actual_power * time_step / 3600
        self.current_energy -= energy_released / self.efficiency

        if self.current_energy < self.min_energy:
            self.current_energy = self.min_energy
            actual_power = 0

        return actual_power

    def step(self, target_power, time_step):
        if target_power < 0:
            actual_power = self.charge(-target_power, time_step)
            actual_power = -actual_power
        else:
            actual_power = self.discharge(target_power, time_step)

        self.power_history.append(actual_power)
        self.energy_history.append(self.current_energy)
        self.soc_history.append(self.calculate_soc())
        return actual_power


class SuperCapacitor:
    """超级电容（快速功率型）"""

    def __init__(self, params):
        self.rated_power = params['rated_power']
        self.max_energy = params['max_energy']
        self.min_energy = params['min_energy']
        self.efficiency = params['efficiency']
        self.current_energy = (self.max_energy + self.min_energy) / 2  # 初始储能（50%）
        self.power_history = []
        self.energy_history = []
        self.soc_history = []

    def calculate_soc(self):
        return (self.current_energy - self.min_energy) / (self.max_energy - self.min_energy)

    def pwm_control(self, target_power, duty_cycle):
        return target_power * duty_cycle

    def charge(self, power, time_step):
        power = min(power, self.rated_power)
        actual_power = self.pwm_control(power, PWM_DUTY_CYCLE)
        energy_absorbed = actual_power * time_step / 3600
        self.current_energy += energy_absorbed * self.efficiency

        if self.current_energy > self.max_energy:
            self.current_energy = self.max_energy
            actual_power = 0

        return actual_power

    def discharge(self, power, time_step):
        power = min(power, self.rated_power)
        actual_power = self.pwm_control(power, PWM_DUTY_CYCLE)
        energy_released = actual_power * time_step / 3600
        self.current_energy -= energy_released / self.efficiency

        if self.current_energy < self.min_energy:
            self.current_energy = self.min_energy
            actual_power = 0

        return actual_power

    def step(self, target_power, time_step):
        if target_power < 0:
            actual_power = self.charge(-target_power, time_step)
            actual_power = -actual_power
        else:
            actual_power = self.discharge(target_power, time_step)

        self.power_history.append(actual_power)
        self.energy_history.append(self.current_energy)
        self.soc_history.append(self.calculate_soc())
        return actual_power


class FESS:
    """飞轮储能（快速功率型）"""

    def __init__(self, params):
        self.rated_power = params['rated_power']
        self.max_energy = params['max_energy']
        self.min_energy = params['min_energy']
        self.efficiency = params['efficiency']
        self.current_energy = (self.max_energy + self.min_energy) / 2  # 初始储能（50%）
        self.power_history = []
        self.energy_history = []
        self.soc_history = []

    def calculate_soc(self):
        return (self.current_energy - self.min_energy) / (self.max_energy - self.min_energy)

    def pwm_control(self, target_power, duty_cycle):
        return target_power * duty_cycle

    def charge(self, power, time_step):
        power = min(power, self.rated_power)
        actual_power = self.pwm_control(power, PWM_DUTY_CYCLE)
        energy_absorbed = actual_power * time_step / 3600
        self.current_energy += energy_absorbed * self.efficiency

        if self.current_energy > self.max_energy:
            self.current_energy = self.max_energy
            actual_power = 0

        return actual_power

    def discharge(self, power, time_step):
        power = min(power, self.rated_power)
        actual_power = self.pwm_control(power, PWM_DUTY_CYCLE)
        energy_released = actual_power * time_step / 3600
        self.current_energy -= energy_released / self.efficiency

        if self.current_energy < self.min_energy:
            self.current_energy = self.min_energy
            actual_power = 0

        return actual_power

    def step(self, target_power, time_step):
        if target_power < 0:
            actual_power = self.charge(-target_power, time_step)
            actual_power = -actual_power
        else:
            actual_power = self.discharge(target_power, time_step)

        self.power_history.append(actual_power)
        self.energy_history.append(self.current_energy)
        self.soc_history.append(self.calculate_soc())
        return actual_power


class SMES:
    """超导磁储能（超快速功率型）"""

    def __init__(self, params):
        self.rated_power = params['rated_power']
        self.max_energy = params['max_energy']
        self.min_energy = params['min_energy']
        self.efficiency = params['efficiency']
        self.current_energy = (self.max_energy + self.min_energy) / 2  # 初始储能（50%）
        self.power_history = []
        self.energy_history = []
        self.soc_history = []

    def calculate_soc(self):
        return (self.current_energy - self.min_energy) / (self.max_energy - self.min_energy)

    def pwm_control(self, target_power, duty_cycle):
        return target_power * duty_cycle

    def charge(self, power, time_step):
        power = min(power, self.rated_power)
        actual_power = self.pwm_control(power, PWM_DUTY_CYCLE)
        energy_absorbed = actual_power * time_step / 3600
        self.current_energy += energy_absorbed * self.efficiency

        if self.current_energy > self.max_energy:
            self.current_energy = self.max_energy
            actual_power = 0

        return actual_power

    def discharge(self, power, time_step):
        power = min(power, self.rated_power)
        actual_power = self.pwm_control(power, PWM_DUTY_CYCLE)
        energy_released = actual_power * time_step / 3600
        self.current_energy -= energy_released / self.efficiency

        if self.current_energy < self.min_energy:
            self.current_energy = self.min_energy
            actual_power = 0

        return actual_power

    def step(self, target_power, time_step):
        if target_power < 0:
            actual_power = self.charge(-target_power, time_step)
            actual_power = -actual_power
        else:
            actual_power = self.discharge(target_power, time_step)

        self.power_history.append(actual_power)
        self.energy_history.append(self.current_energy)
        self.soc_history.append(self.calculate_soc())
        return actual_power


# ============================ 4. 分层随机MPC控制器 ============================
class HierarchicalMPC:
    """分层随机MPC控制器：上层经济调度 + 下层实时平衡"""

    def __init__(self, storage_units):
        self.storage_units = storage_units  # 储能单元字典
        self.forecast_horizon = 12  # 预测时域（12个时间步，12分钟）
        self.control_horizon = 6  # 控制时域（6个时间步，6分钟）
        self.units = ['CAES', 'BESS', 'SC', 'FESS', 'SMES']  # 所有储能单元列表

    def get_current_price(self, step):
        """根据时间步获取当前电价"""
        time_hour = (step * TIME_STEP) / 3600  # 当前小时数
        if (0 <= time_hour < 6) or (11 <= time_hour < 13):
            return ELECTRICITY_PRICE['valley']
        elif (6 <= time_hour < 11) or (13 <= time_hour < 14) or (22 <= time_hour < 24):
            return ELECTRICITY_PRICE['flat']
        elif (14 <= time_hour < 18) or (20 <= time_hour < 22):
            return ELECTRICITY_PRICE['peak']
        elif 18 <= time_hour < 20:
            return ELECTRICITY_PRICE['sharp_peak']
        else:
            return ELECTRICITY_PRICE['flat']

    def upper_layer_economic_dispatch(self, step, unbalanced_power):
        """上层MPC：经济调度（最小化运行成本），确保所有单元都分配到功率"""
        current_price = self.get_current_price(step)
        target_powers = {unit: 0 for unit in self.units}  # 初始化所有单元的目标功率为0

        # 基于电价和储能特性分配目标功率
        if unbalanced_power < 0:  # 有多余电能，需要充电
            # 低价时段：CAES优先充电
            if current_price == ELECTRICITY_PRICE['valley']:
                target_powers['CAES'] = unbalanced_power * 0.6
                target_powers['BESS'] = unbalanced_power * 0.3
                target_powers['SC'] = unbalanced_power * 0.05
                target_powers['FESS'] = unbalanced_power * 0.03
                target_powers['SMES'] = unbalanced_power * 0.02
            # 平段时段：均衡充电
            else:
                target_powers['CAES'] = unbalanced_power * 0.5
                target_powers['BESS'] = unbalanced_power * 0.25
                target_powers['SC'] = unbalanced_power * 0.1
                target_powers['FESS'] = unbalanced_power * 0.1
                target_powers['SMES'] = unbalanced_power * 0.05

        else:  # 电能不足，需要放电
            # 高价/尖峰时段：快速储能优先放电
            if current_price in [ELECTRICITY_PRICE['peak'], ELECTRICITY_PRICE['sharp_peak']]:
                target_powers['SC'] = unbalanced_power * 0.25
                target_powers['FESS'] = unbalanced_power * 0.15
                target_powers['SMES'] = unbalanced_power * 0.10
                target_powers['BESS'] = unbalanced_power * 0.30
                target_powers['CAES'] = unbalanced_power * 0.20
            # 平段时段：均衡放电
            else:
                target_powers['CAES'] = unbalanced_power * 0.25
                target_powers['BESS'] = unbalanced_power * 0.25
                target_powers['SC'] = unbalanced_power * 0.2
                target_powers['FESS'] = unbalanced_power * 0.2
                target_powers['SMES'] = unbalanced_power * 0.1

        return target_powers

    def lower_layer_realtime_balance(self, target_powers, unbalanced_power):
        """下层MPC：实时平衡（最小化偏差，PWM调节）"""
        # 计算目标总功率
        target_total = sum(target_powers.values())
        # 计算偏差，进行二次调节
        deviation = unbalanced_power - target_total
        adjustment_ratio = {
            'SMES': 0.4,  # 超导磁：调节40%偏差（响应最快）
            'SC': 0.3,  # 超级电容：调节30%偏差（响应快）
            'FESS': 0.2,  # 飞轮：调节20%偏差（响应较快）
            'BESS': 0.08,  # 锂电池：调节8%偏差
            'CAES': 0.02  # 压缩空气：调节2%偏差（响应最慢）
        }

        # 偏差调节（确保所有单元都被调整）
        for unit in self.units:
            target_powers[unit] += deviation * adjustment_ratio[unit]

        return target_powers

    def step(self, step, unbalanced_power):
        """MPC控制器单步运行"""
        # 上层经济调度：分配目标功率（确保所有单元都有值）
        target_powers = self.upper_layer_economic_dispatch(step, unbalanced_power)
        # 下层实时平衡：偏差修正
        target_powers = self.lower_layer_realtime_balance(target_powers, unbalanced_power)

        # 执行各储能单元出力
        actual_powers = {}
        total_actual_power = 0
        for unit_name in self.units:
            storage_unit = self.storage_units[unit_name]
            actual_power = storage_unit.step(target_powers[unit_name], TIME_STEP)
            actual_powers[unit_name] = actual_power
            total_actual_power += actual_power

        return actual_powers, total_actual_power


# ============================ 5. 系统初始化与仿真 ============================
def initialize_system():
    """初始化储能系统和控制器"""
    # 创建各储能单元实例
    storage_units = {
        'CAES': CAES(STORAGE_PARAMS['CAES']),
        'BESS': BESS(STORAGE_PARAMS['BESS']),
        'SC': SuperCapacitor(STORAGE_PARAMS['SC']),
        'FESS': FESS(STORAGE_PARAMS['FESS']),
        'SMES': SMES(STORAGE_PARAMS['SMES'])
    }

    # 创建MPC控制器
    mpc_controller = HierarchicalMPC(storage_units)

    return storage_units, mpc_controller


def run_simulation():
    """运行24小时仿真"""
    # 初始化系统
    storage_units, mpc_controller = initialize_system()

    # 生成电源和负荷曲线
    generation_curve = generate_generation_profile()
    load_curve = generate_load_profile()
    unbalanced_power_curve = calculate_unbalanced_power(generation_curve, load_curve)

    # 记录数据
    time_list = np.linspace(0, SIMULATION_HOURS, TOTAL_STEPS)
    total_actual_power_list = []  # 储能总出力
    power_deviation_list = []  # 功率偏差
    price_list = []  # 电价历史

    # 各储能单元功率历史（用于功率分配占比图）
    power_history = {unit: [] for unit in storage_units.keys()}

    # 开始仿真
    print("开始24小时混合储能系统仿真...")
    for step in range(TOTAL_STEPS):
        # 当前待平衡功率
        current_unbalanced = unbalanced_power_curve[step]
        # MPC控制
        actual_powers, total_actual = mpc_controller.step(step, current_unbalanced)
        # 计算偏差
        deviation = current_unbalanced - total_actual
        # 记录数据
        total_actual_power_list.append(total_actual)
        power_deviation_list.append(deviation)
        price_list.append(mpc_controller.get_current_price(step))
        for unit, power in actual_powers.items():
            power_history[unit].append(power)

        # 每1小时输出进度
        if (step + 1) % (60 / (TIME_STEP / 60)) == 0:
            hour = (step + 1) * TIME_STEP / 3600
            print(f"仿真进度：{hour:.1f}小时，当前偏差：{deviation:.2f}kW")

    print("仿真完成！")

    # 整理数据用于绘图
    results = {
        'time': time_list,
        'generation': generation_curve,
        'load': load_curve,
        'unbalanced_power': unbalanced_power_curve,
        'storage_total_power': total_actual_power_list,
        'deviation': power_deviation_list,
        'price': price_list,
        'power_history': power_history,
        'storage_units': storage_units
    }

    return results


# ============================ 6. 结果可视化 ============================
def plot_results(results):
    """绘制所有要求的图表"""
    time = results['time']
    generation = results['generation']
    load = results['load']
    unbalanced_power = results['unbalanced_power']
    storage_total_power = results['storage_total_power']
    deviation = results['deviation']
    price = results['price']
    power_history = results['power_history']
    storage_units = results['storage_units']

    # 创建2x2子图布局（4个主要图表）
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('12MW园区级混合储能系统协同调度仿真结果', fontsize=16, fontweight='bold')

    # 图1：功率平衡效果图（含待平衡功率和储能总出力）
    ax1 = axes[0, 0]
    ax1.plot(time, unbalanced_power, label='待平衡功率', color='#ff7f0e', linewidth=1.5, alpha=0.8)
    ax1.plot(time, storage_total_power, label='储能总出力', color='#1f77b4', linewidth=2.0)
    ax1.axhline(y=0, color='black', linestyle='--', alpha=0.5, label='功率平衡线')
    ax1.set_xlabel('时间 (小时)')
    ax1.set_ylabel('功率 (kW)')
    ax1.set_title('功率平衡效果图（偏差最小化目标）')
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # 图2：各储能单元SOC变化图
    ax2 = axes[0, 1]
    colors = ['#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2']
    units = ['CAES', 'BESS', 'SC', 'FESS', 'SMES']
    for i, unit in enumerate(units):
        soc_history = storage_units[unit].soc_history
        ax2.plot(time, soc_history, label=f'{unit} SOC', color=colors[i], linewidth=1.5)
    ax2.set_xlabel('时间 (小时)')
    ax2.set_ylabel('SOC (0-1)')
    ax2.set_title('各储能单元荷电状态(SOC)变化')
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    ax2.set_ylim(0, 1.05)

    # 图3：系统功率平衡图（电源+储能=负荷）
    ax3 = axes[1, 0]
    # 计算平衡后的总供电功率（电源出力 + 储能出力）
    balanced_power = generation + storage_total_power
    ax3.plot(time, load, label='园区负荷', color='#ff7f0e', linewidth=2.0, alpha=0.8)
    ax3.plot(time, balanced_power, label='平衡后总供电', color='#2ca02c', linewidth=1.5)
    ax3.fill_between(time, load, balanced_power, alpha=0.2, color='gray', label='功率偏差区域')
    ax3.set_xlabel('时间 (小时)')
    ax3.set_ylabel('功率 (kW)')
    ax3.set_title('系统功率平衡总览')
    ax3.legend()
    ax3.grid(True, alpha=0.3)

    # 图4：功率分配占比变化图
    ax4 = axes[1, 1]
    # 计算各储能单元的功率占比（绝对值）
    total_power_abs = np.abs(storage_total_power) + 1e-6  # 避免除零
    for i, unit in enumerate(units):
        power_abs = np.abs(np.array(power_history[unit]))
        ratio = power_abs / total_power_abs
        ax4.plot(time, ratio, label=f'{unit} 占比', color=colors[i], linewidth=1.5)
    ax4.set_xlabel('时间 (小时)')
    ax4.set_ylabel('功率占比 (0-1)')
    ax4.set_title('各储能单元功率分配占比变化')
    ax4.legend()
    ax4.grid(True, alpha=0.3)
    ax4.set_ylim(0, 1.05)

    # 调整布局
    plt.tight_layout()
    plt.subplots_adjust(top=0.92)
    plt.savefig('混合储能系统仿真结果.png', dpi=300, bbox_inches='tight')
    plt.show()

    # 额外绘制能量变化图（单独窗口）
    fig2, ax = plt.subplots(figsize=(12, 6))
    for i, unit in enumerate(units):
        energy_history = storage_units[unit].energy_history
        ax.plot(time, energy_history, label=f'{unit} 能量', color=colors[i], linewidth=1.5)
    ax.set_xlabel('时间 (小时)')
    ax.set_ylabel('能量 (kWh)')
    ax.set_title('各储能单元能量变化曲线')
    ax.legend()
    ax.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig('储能单元能量变化图.png', dpi=300, bbox_inches='tight')
    plt.show()

    # 输出关键性能指标
    print("\n=== 系统关键性能指标 ===")
    avg_deviation = np.mean(np.abs(deviation))
    max_deviation = np.max(np.abs(deviation))
    total_cost = np.sum(np.array(storage_total_power) * np.array(price) * TIME_STEP / 3600)
    print(f"平均功率偏差：{avg_deviation:.2f}kW")
    print(f"最大功率偏差：{max_deviation:.2f}kW")
    print(f"24小时总运行成本：{total_cost:.2f}元")
    print(f"功率偏差率：{avg_deviation / np.mean(np.abs(unbalanced_power)) * 100:.2f}%")


# ============================ 7. 主程序执行 ============================
if __name__ == "__main__":
    # 运行仿真
    simulation_results = run_simulation()
    # 绘制结果图表
    plot_results(simulation_results)
