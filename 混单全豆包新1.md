import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.optimize import linprog
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# ============================ 1. åŸºç¡€å‚æ•°å®šä¹‰ ============================
class BaseParams:
    """ç³»ç»ŸåŸºç¡€å‚æ•°ï¼ˆå‚è€ƒå—äº¬å†¬å­£å·¥å•†ä¸šæ•°æ®ï¼‰"""
    # ç”µä»·ï¼ˆå…ƒ/kWhï¼‰
    ELECTRICITY_PRICE = {
        'valley': 0.21,    # ä½è°·ï¼ˆ00:00-06:00, 11:00-13:00ï¼‰
        'flat': 0.62,      # å¹³æ®µ
        'peak': 1.12,      # é«˜å³°ï¼ˆ14:00-22:00ï¼‰
        'sharp_peak': 1.34 # å°–å³°ï¼ˆ18:00-20:00ï¼‰
    }
    # å¤©ç„¶æ°”ä»·æ ¼ï¼ˆå…ƒ/mÂ³ï¼‰
    GAS_PRICE = 3.6
    # ç³»ç»Ÿå‚æ•°
    PLANT_POWER = 13e3  # ç”µå‚é¢å®šåŠŸç‡ï¼ˆkWï¼‰
    BASE_LOAD = 10e3    # ç”¨æˆ·åŸºæœ¬è´Ÿè·ï¼ˆkWï¼‰
    # è„‰å†²å‚æ•°
    PULSE_BASE = 18e3   # åŸºç¡€è„‰å†²åŠŸç‡ï¼ˆkWï¼‰
    PULSE_PEAK = 20e3   # å³°å€¼è„‰å†²åŠŸç‡ï¼ˆkWï¼‰
    PULSE_DUR1 = 10     # åŸºç¡€è„‰å†²æŒç»­æ—¶é—´ï¼ˆsï¼‰
    PULSE_DUR2 = 20     # å³°å€¼è„‰å†²æŒç»­æ—¶é—´ï¼ˆsï¼‰
    SIM_TIME = 50       # æ€»ä»¿çœŸæ—¶é—´ï¼ˆsï¼‰
    SAMPLING_TIME = 0.01# é‡‡æ ·æ—¶é—´ï¼ˆsï¼‰â†’ ä¿è¯PWMé«˜é¢‘å“åº”

# ============================ 2. å‚¨èƒ½å•å…ƒç±»ï¼ˆå«PWMæ§åˆ¶ï¼‰ ============================
class SMES:
    """è¶…å¯¼ç£å‚¨èƒ½ï¼ˆSMESï¼‰- å¾®ç§’çº§å“åº”ï¼ŒåŠŸç‡å‹"""
    def __init__(self):
        self.power_rated = 2e3  # é¢å®šåŠŸç‡ï¼ˆkWï¼‰
        self.energy_max = 500   # æœ€å¤§å®¹é‡ï¼ˆkWhï¼‰â†’ 0.5MWh
        self.energy_current = 250  # åˆå§‹ç”µé‡ï¼ˆkWhï¼‰
        self.efficiency_charge = 0.98  # å……ç”µæ•ˆç‡
        self.efficiency_discharge = 0.98  # æ”¾ç”µæ•ˆç‡
        self.response_time = 1e-6  # å“åº”æ—¶é—´ï¼ˆsï¼‰
        self.pwm_frequency = 1000  # PWMé¢‘ç‡ï¼ˆ1kHzï¼‰
        self.duty_cycle = 0.5  # åˆå§‹å ç©ºæ¯”ï¼ˆ0-1ï¼‰

    def update(self, power_ref, t):
        """æ ¹æ®å‚è€ƒåŠŸç‡å’ŒPWMæ›´æ–°çŠ¶æ€"""
        # PWMè°ƒåˆ¶ï¼šå ç©ºæ¯”å†³å®šæœ‰æ•ˆå‡ºåŠ›
        pwm_signal = self._pwm_generator(t)
        power_effective = power_ref * pwm_signal * self.duty_cycle

        # åŠŸç‡çº¦æŸ
        power_effective = np.clip(power_effective, -self.power_rated, self.power_rated)

        # èƒ½é‡æ›´æ–°
        delta_energy = power_effective * BaseParams.SAMPLING_TIME / 3600
        if power_effective < 0:  # å……ç”µï¼ˆè´ŸåŠŸç‡ä¸ºå……ç”µï¼‰
            delta_energy *= self.efficiency_charge
        else:  # æ”¾ç”µ
            delta_energy /= self.efficiency_discharge

        self.energy_current = np.clip(
            self.energy_current + delta_energy,
            0, self.energy_max
        )

        # è®¡ç®—ç”µæµç”µå‹ï¼ˆè¶…å¯¼çº¿åœˆï¼šE=0.5LIÂ² â†’ I=âˆš(2E/L)ï¼Œå‡è®¾L=100Hï¼‰
        inductance = 100  # ç”µæ„Ÿï¼ˆHï¼‰
        current = np.sqrt(2 * self.energy_current * 3600 / inductance)  # è½¬æ¢ä¸ºJè®¡ç®—
        voltage = inductance * (power_effective / (current + 1e-6))  # V=P/Iï¼ˆè¿‘ä¼¼ï¼‰

        return {
            'power': power_effective,
            'energy': self.energy_current,
            'current': current,
            'voltage': voltage,
            'duty_cycle': self.duty_cycle
        }

    def _pwm_generator(self, t):
        """ç”ŸæˆPWMä¿¡å·ï¼ˆæ–¹æ³¢ï¼‰"""
        return 1 if (t * self.pwm_frequency) % 1 < self.duty_cycle else 0

class Supercapacitor:
    """è¶…çº§ç”µå®¹ï¼ˆSCï¼‰- æ¯«ç§’çº§å“åº”ï¼ŒåŠŸç‡å‹"""
    def __init__(self):
        self.power_rated = 3e3  # é¢å®šåŠŸç‡ï¼ˆkWï¼‰
        self.energy_max = 1000  # æœ€å¤§å®¹é‡ï¼ˆkWhï¼‰â†’ 1MWh
        self.energy_current = 500  # åˆå§‹ç”µé‡ï¼ˆkWhï¼‰
        self.efficiency_charge = 0.95  # å……ç”µæ•ˆç‡
        self.efficiency_discharge = 0.95  # æ”¾ç”µæ•ˆç‡
        self.response_time = 0.001  # å“åº”æ—¶é—´ï¼ˆsï¼‰
        self.pwm_frequency = 1000  # PWMé¢‘ç‡ï¼ˆ1kHzï¼‰
        self.duty_cycle = 0.5  # åˆå§‹å ç©ºæ¯”

    def update(self, power_ref, t):
        """æ›´æ–°çŠ¶æ€"""
        pwm_signal = self._pwm_generator(t)
        power_effective = power_ref * pwm_signal * self.duty_cycle
        power_effective = np.clip(power_effective, -self.power_rated, self.power_rated)

        delta_energy = power_effective * BaseParams.SAMPLING_TIME / 3600
        if power_effective < 0:
            delta_energy *= self.efficiency_charge
        else:
            delta_energy /= self.efficiency_discharge

        self.energy_current = np.clip(
            self.energy_current + delta_energy,
            0, self.energy_max
        )

        # ç”µå®¹ç‰¹æ€§ï¼šE=0.5CVÂ² â†’ V=âˆš(2E/C)ï¼Œå‡è®¾C=3000F
        capacitance = 3000  # ç”µå®¹ï¼ˆFï¼‰
        voltage = np.sqrt(2 * self.energy_current * 3600 / capacitance)  # è½¬æ¢ä¸ºJ
        current = power_effective / (voltage + 1e-6)  # I=P/V

        return {
            'power': power_effective,
            'energy': self.energy_current,
            'current': current,
            'voltage': voltage,
            'duty_cycle': self.duty_cycle
        }

    def _pwm_generator(self, t):
        return 1 if (t * self.pwm_frequency) % 1 < self.duty_cycle else 0

class FlywheelModel:
    """é£è½®å‚¨èƒ½ï¼ˆFESSï¼‰- ç§’çº§å“åº”ï¼Œä¸­åŠŸç‡å‹"""
    def __init__(self):
        self.power_rated = 4e3  # é¢å®šåŠŸç‡ï¼ˆkWï¼‰
        self.energy_max = 2000  # æœ€å¤§å®¹é‡ï¼ˆkWhï¼‰â†’ 2MWh
        self.energy_current = 1000  # åˆå§‹ç”µé‡ï¼ˆkWhï¼‰
        self.efficiency = 0.92  # ç»¼åˆæ•ˆç‡
        self.response_time = 1  # å“åº”æ—¶é—´ï¼ˆsï¼‰
        self.pwm_frequency = 100  # PWMé¢‘ç‡ï¼ˆ100Hzï¼‰
        self.duty_cycle = 0.5  # åˆå§‹å ç©ºæ¯”

    def update(self, power_ref, t):
        """æ›´æ–°çŠ¶æ€"""
        pwm_signal = self._pwm_generator(t)
        power_effective = power_ref * pwm_signal * self.duty_cycle
        power_effective = np.clip(power_effective, -self.power_rated, self.power_rated)

        delta_energy = power_effective * BaseParams.SAMPLING_TIME / 3600 * self.efficiency
        self.energy_current = np.clip(
            self.energy_current + delta_energy,
            0, self.energy_max
        )

        # é£è½®ç‰¹æ€§ï¼šE=0.5JÏ‰Â² â†’ Ï‰=âˆš(2E/J)ï¼Œå‡è®¾J=1000 kgÂ·mÂ²
        moment_inertia = 1000  # è½¬åŠ¨æƒ¯é‡
        angular_vel = np.sqrt(2 * self.energy_current * 3600 / moment_inertia)  # è½¬æ¢ä¸ºJ
        # åŠŸç‡P=TÏ‰ â†’ æ‰­çŸ©T=P/Ï‰ï¼Œç”µæµä¸æ‰­çŸ©æˆæ­£æ¯”ï¼ˆè¿‘ä¼¼ç”µæµ=P/(kÏ‰)ï¼Œk=10ï¼‰
        current = power_effective / (10 * angular_vel + 1e-6)
        voltage = power_effective / (current + 1e-6)  # V=P/I

        return {
            'power': power_effective,
            'energy': self.energy_current,
            'current': current,
            'voltage': voltage,
            'duty_cycle': self.duty_cycle
        }

    def _pwm_generator(self, t):
        return 1 if (t * self.pwm_frequency) % 1 < self.duty_cycle else 0

class LithiumIonBattery:
    """é”‚ç”µå‚¨èƒ½ï¼ˆBESSï¼‰- åˆ†é’Ÿçº§å“åº”ï¼Œèƒ½é‡å‹"""
    def __init__(self):
        self.power_rated = 5e3  # é¢å®šåŠŸç‡ï¼ˆkWï¼‰
        self.energy_max = 10000  # æœ€å¤§å®¹é‡ï¼ˆkWhï¼‰â†’ 10MWh
        self.energy_current = 5000  # åˆå§‹ç”µé‡ï¼ˆkWhï¼‰
        self.nominal_voltage = 3.7e3  # æ ‡ç§°ç”µå‹ï¼ˆVï¼Œæ¨¡å—åŒ–ï¼‰
        self.internal_resistance = 0.01  # å†…é˜»ï¼ˆÎ©ï¼‰
        self.efficiency_charge = 0.9  # å……ç”µæ•ˆç‡
        self.efficiency_discharge = 0.9  # æ”¾ç”µæ•ˆç‡
        self.response_time = 10  # å“åº”æ—¶é—´ï¼ˆsï¼‰

    def update(self, power_ref):
        """æ›´æ–°çŠ¶æ€ï¼ˆèƒ½é‡å‹æ— éœ€é«˜é¢‘PWMï¼‰"""
        power_effective = np.clip(power_ref, -self.power_rated, self.power_rated)

        delta_energy = power_effective * BaseParams.SAMPLING_TIME / 3600
        if power_effective < 0:
            delta_energy *= self.efficiency_charge
        else:
            delta_energy /= self.efficiency_discharge

        self.energy_current = np.clip(
            self.energy_current + delta_energy,
            0, self.energy_max
        )

        # ç”µæ± ç‰¹æ€§ï¼šç”µæµI=P/Vï¼ŒSOC=å‰©ä½™ç”µé‡/æœ€å¤§ç”µé‡
        current = power_effective / (self.nominal_voltage + 1e-6)
        soc = self.energy_current / self.energy_max

        return {
            'power': power_effective,
            'energy': self.energy_current,
            'soc': soc,
            'current': current,
            'voltage': self.nominal_voltage - current * self.internal_resistance
        }

class CAESystem:
    """å‹ç¼©ç©ºæ°”å‚¨èƒ½ï¼ˆCAESï¼‰- åˆ†é’Ÿçº§å“åº”ï¼Œèƒ½é‡å‹"""
    def __init__(self):
        self.power_rated = 3e3  # é¢å®šåŠŸç‡ï¼ˆkWï¼‰
        self.energy_max = 15000  # æœ€å¤§å®¹é‡ï¼ˆkWhï¼‰â†’ 15MWh
        self.energy_current = 7500  # åˆå§‹ç”µé‡ï¼ˆkWhï¼‰
        self.eta_comp = 0.85  # å‹ç¼©æ•ˆç‡
        self.eta_gen = 0.35  # å‘ç”µæ•ˆç‡
        self.H_f = 45000  # å¤©ç„¶æ°”ä½çƒ­å€¼ï¼ˆkJ/kgï¼‰
        self.response_time = 60  # å“åº”æ—¶é—´ï¼ˆsï¼‰

    def update(self, power_ref):
        """æ›´æ–°çŠ¶æ€"""
        power_effective = np.clip(power_ref, -self.power_rated, self.power_rated)

        # CAESèƒ½é‡è½¬æ¢ï¼šå……ç”µï¼ˆè€—ç”µå‹ç¼©ç©ºæ°”ï¼‰â†’ è´ŸåŠŸç‡ï¼›æ”¾ç”µï¼ˆå‘ç”µï¼‰â†’ æ­£åŠŸç‡
        if power_effective < 0:  # å……ç”µ
            delta_energy = power_effective * self.eta_comp * BaseParams.SAMPLING_TIME / 3600
        else:  # æ”¾ç”µï¼ˆæ¶ˆè€—å¤©ç„¶æ°”ï¼‰
            delta_energy = -power_effective / self.eta_gen * BaseParams.SAMPLING_TIME / 3600
            # å¤©ç„¶æ°”æ¶ˆè€—è®¡ç®—
            self.gas_consumption = power_effective * 0.05 * BaseParams.SAMPLING_TIME / 3600  # ç®€åŒ–ç³»æ•°

        self.energy_current = np.clip(
            self.energy_current + delta_energy,
            0, self.energy_max
        )

        # ç©ºæ°”è´¨é‡ä¸åŠŸç‡å…³ç³»ï¼ˆç®€åŒ–ï¼‰
        mass_air = self.energy_current * 0.1  # 1kWhå¯¹åº”0.1kgç©ºæ°”
        current = power_effective / (1000 + 1e-6)  # è¿‘ä¼¼ç”µæµï¼ˆå‡è®¾ç”µå‹1kVï¼‰
        voltage = 1000  # å‡è®¾ç³»ç»Ÿç”µå‹1kV

        return {
            'power': power_effective,
            'energy': self.energy_current,
            'mass_air': mass_air,
            'current': current,
            'voltage': voltage,
            'gas_consumption': self.gas_consumption if 'gas_consumption' in locals() else 0
        }

# ============================ 3. åˆ†å±‚MPCæ§åˆ¶å™¨ ============================
class HierarchicalMPC:
    """åˆ†å±‚æ¨¡å‹é¢„æµ‹æ§åˆ¶å™¨ï¼šä¸Šå±‚ç»æµè°ƒåº¦ï¼Œä¸‹å±‚å®æ—¶å¹³è¡¡"""
    def __init__(self, storages):
        self.storages = storages  # å‚¨èƒ½å®ä¾‹åˆ—è¡¨
        self.horizon = 5  # é¢„æµ‹æ—¶åŸŸï¼ˆ5ä¸ªé‡‡æ ·ç‚¹ï¼‰
        self.weight_cost = 1.0  # æˆæœ¬æƒé‡
        self.weight_deviation = 10.0  # åå·®æƒé‡ï¼ˆä¼˜å…ˆæŠ¹å¹³è„‰å†²ï¼‰

    def upper_layer(self, unbalance_power, t):
        """ä¸Šå±‚ç»æµè°ƒåº¦ï¼šè®¡ç®—å„å‚¨èƒ½å‡ºåŠ›å‚è€ƒå€¼ï¼ˆæœ€å°åŒ–æˆæœ¬+åå·®ï¼‰"""
        # 1. ç¡®å®šå½“å‰ç”µä»·æ—¶æ®µ
        hour = (t / 3600) % 24  # è½¬æ¢ä¸ºå°æ—¶
        if (0 <= hour < 6) or (11 <= hour < 13):
            price = BaseParams.ELECTRICITY_PRICE['valley']
        elif (6 <= hour < 11) or (13 <= hour < 14) or (22 <= hour < 24):
            price = BaseParams.ELECTRICITY_PRICE['flat']
        elif (14 <= hour < 18) or (20 <= hour < 22):
            price = BaseParams.ELECTRICITY_PRICE['peak']
        else:
            price = BaseParams.ELECTRICITY_PRICE['sharp_peak']

        # 2. å‚¨èƒ½æˆæœ¬ç³»æ•°ï¼ˆå…ƒ/kWhï¼Œå‚è€ƒæ–‡æ¡£7ï¼‰
        cost_coeffs = [
            65  # SMESï¼ˆå…ƒ/kWhï¼‰
            , 2.0  # SCï¼ˆå…ƒ/kWhï¼‰
            , 10.0  # FESSï¼ˆå…ƒ/kW â†’ è½¬æ¢ä¸ºkWhæˆæœ¬ï¼š10000å…ƒ/kW / 1000æ¬¡å¾ªç¯ = 10å…ƒ/kWhï¼‰
            , 0.7  # BESSï¼ˆå…ƒ/kWhï¼‰
            , 2.75  # CAESï¼ˆå…ƒ/kWhï¼‰
        ]

        # 3. çº¿æ€§è§„åˆ’ç›®æ ‡ï¼šmin(æˆæœ¬*æƒé‡ + åå·®*æƒé‡)
        n_storages = len(self.storages)
        # ç›®æ ‡å‡½æ•°ç³»æ•°ï¼š[æˆæœ¬ç³»æ•°*æƒé‡ + 1ï¼ˆåå·®é¡¹ï¼‰*æƒé‡]
        c = [self.weight_cost * cost_coeffs[i] + self.weight_deviation for i in range(n_storages)]

        # 4. çº¦æŸæ¡ä»¶ï¼šÎ£å‚¨èƒ½å‡ºåŠ› = ä¸å¹³è¡¡åŠŸç‡
        A = np.ones((1, n_storages))
        b = [unbalance_power]

        # 5. åŠŸç‡ä¸Šä¸‹é™çº¦æŸ
        bounds = [
            (-self.storages[0].power_rated, self.storages[0].power_rated),  # SMES
            (-self.storages[1].power_rated, self.storages[1].power_rated),  # SC
            (-self.storages[2].power_rated, self.storages[2].power_rated),  # FESS
            (-self.storages[3].power_rated, self.storages[3].power_rated),  # BESS
            (-self.storages[4].power_rated, self.storages[4].power_rated)   # CAES
        ]

        # 6. æ±‚è§£çº¿æ€§è§„åˆ’
        result = linprog(c, A_eq=A, b_eq=b, bounds=bounds, method='highs')
        power_refs = result.x if result.success else np.zeros(n_storages)

        # 7. æŒ‰å“åº”é€Ÿåº¦åˆ†é…ä¼˜å…ˆçº§ï¼ˆä¿®æ­£å‚è€ƒå€¼ï¼Œç¡®ä¿å¿«é€Ÿå‚¨èƒ½å…ˆå“åº”ï¼‰
        speed_weights = [0.3, 0.25, 0.2, 0.15, 0.1]  # å“åº”é€Ÿåº¦æƒé‡ï¼ˆSMESæœ€é«˜ï¼‰
        power_refs = power_refs * speed_weights / np.sum(speed_weights) * unbalance_power / np.sum(power_refs + 1e-6)

        return power_refs

    def lower_layer(self, power_refs, t):
        """ä¸‹å±‚å®æ—¶å¹³è¡¡ï¼šPWMè°ƒèŠ‚å¿«é€Ÿå‚¨èƒ½ï¼Œæœ€å°åŒ–åå·®"""
        outputs = []
        for i, (storage, ref) in enumerate(zip(self.storages, power_refs)):
            if i < 3:  # å¿«é€Ÿå‚¨èƒ½ï¼ˆSMES/SC/FESSï¼‰å¯ç”¨PWM
                output = storage.update(ref, t)
                # åŠ¨æ€è°ƒæ•´å ç©ºæ¯”ï¼šåå·®å¤§æ—¶å¢å¤§å ç©ºæ¯”
                actual_power = output['power']
                duty_cycle_adjust = np.clip(1 - abs(actual_power - ref) / (ref + 1e-6), 0.1, 0.9)
                storage.duty_cycle = duty_cycle_adjust
            else:  # èƒ½é‡å‚¨èƒ½ï¼ˆBESS/CAESï¼‰æ— éœ€PWM
                output = storage.update(ref)
            outputs.append(output)
        return outputs

# ============================ 4. ç³»ç»Ÿä»¿çœŸ ============================
def simulate_system():
    # 1. åˆå§‹åŒ–å‚¨èƒ½å•å…ƒ
    smes = SMES()
    sc = Supercapacitor()
    fess = FlywheelModel()
    bess = LithiumIonBattery()
    caes = CAESystem()
    storages = [smes, sc, fess, bess, caes]
    storage_names = ['SMES', 'è¶…çº§ç”µå®¹', 'é£è½®', 'é”‚ç”µ', 'å‹ç¼©ç©ºæ°”']

    # 2. åˆå§‹åŒ–MPCæ§åˆ¶å™¨
    mpc = HierarchicalMPC(storages)

    # 3. åˆå§‹åŒ–ä»¿çœŸæ•°æ®
    time_points = np.arange(0, BaseParams.SIM_TIME, BaseParams.SAMPLING_TIME)
    simulation_data = {
        'time': [], 'total_load': [], 'plant_power': [], 'unbalance_power': [],
        'smes_power': [], 'sc_power': [], 'fess_power': [], 'bess_power': [], 'caes_power': [],
        'smes_energy': [], 'sc_energy': [], 'fess_energy': [], 'bess_energy': [], 'caes_energy': [],
        'smes_current': [], 'sc_current': [], 'fess_current': [], 'bess_current': [], 'caes_current': [],
        'smes_voltage': [], 'sc_voltage': [], 'fess_voltage': [], 'bess_voltage': [], 'caes_voltage': [],
        'total_storage_power': [], 'smoothed_load': []
    }

    # 4. è¿è¡Œä»¿çœŸ
    for t in time_points:
        # ç”Ÿæˆè„‰å†²è´Ÿè·ï¼š0-10s=18MWï¼Œ10-30s=20MWï¼Œ30-50s=0
        if 0 <= t < BaseParams.PULSE_DUR1:
            pulse = BaseParams.PULSE_BASE
        elif BaseParams.PULSE_DUR1 <= t < BaseParams.PULSE_DUR1 + BaseParams.PULSE_DUR2:
            pulse = BaseParams.PULSE_PEAK
        else:
            pulse = 0
        total_load = BaseParams.BASE_LOAD + pulse  # æ€»è´Ÿè·
        unbalance_power = total_load - BaseParams.PLANT_POWER  # ä¸å¹³è¡¡åŠŸç‡ï¼ˆéœ€å‚¨èƒ½æŠµæ¶ˆï¼‰

        # MPCæ§åˆ¶ï¼šä¸Šå±‚ç»æµè°ƒåº¦â†’ä¸‹å±‚å®æ—¶å¹³è¡¡
        power_refs = mpc.upper_layer(unbalance_power, t)
        storage_outputs = mpc.lower_layer(power_refs, t)

        # è®¡ç®—æ€»å‚¨èƒ½å‡ºåŠ›å’ŒæŠ¹å¹³åçš„è´Ÿè·
        total_storage_power = sum([out['power'] for out in storage_outputs])
        smoothed_load = BaseParams.PLANT_POWER + total_storage_power  # æŠ¹å¹³åçš„ç”¨æˆ·ç«¯è´Ÿè·

        # è®°å½•æ•°æ®
        simulation_data['time'].append(t)
        simulation_data['total_load'].append(total_load)
        simulation_data['plant_power'].append(BaseParams.PLANT_POWER)
        simulation_data['unbalance_power'].append(unbalance_power)
        simulation_data['smes_power'].append(storage_outputs[0]['power'])
        simulation_data['sc_power'].append(storage_outputs[1]['power'])
        simulation_data['fess_power'].append(storage_outputs[2]['power'])
        simulation_data['bess_power'].append(storage_outputs[3]['power'])
        simulation_data['caes_power'].append(storage_outputs[4]['power'])
        simulation_data['smes_energy'].append(storage_outputs[0]['energy'])
        simulation_data['sc_energy'].append(storage_outputs[1]['energy'])
        simulation_data['fess_energy'].append(storage_outputs[2]['energy'])
        simulation_data['bess_energy'].append(storage_outputs[3]['energy'])
        simulation_data['caes_energy'].append(storage_outputs[4]['energy'])
        simulation_data['smes_current'].append(storage_outputs[0]['current'])
        simulation_data['sc_current'].append(storage_outputs[1]['current'])
        simulation_data['fess_current'].append(storage_outputs[2]['current'])
        simulation_data['bess_current'].append(storage_outputs[3]['current'])
        simulation_data['caes_current'].append(storage_outputs[4]['current'])
        simulation_data['smes_voltage'].append(storage_outputs[0]['voltage'])
        simulation_data['sc_voltage'].append(storage_outputs[1]['voltage'])
        simulation_data['fess_voltage'].append(storage_outputs[2]['voltage'])
        simulation_data['bess_voltage'].append(storage_outputs[3]['voltage'])
        simulation_data['caes_voltage'].append(storage_outputs[4]['voltage'])
        simulation_data['total_storage_power'].append(total_storage_power)
        simulation_data['smoothed_load'].append(smoothed_load)

    # 5. è½¬æ¢ä¸ºDataFrameä¾¿äºåˆ†æ
    df = pd.DataFrame(simulation_data)
    return df, storage_names

# ============================ 5. ç»“æœåˆ†æä¸å¯è§†åŒ– ============================
def analyze_results(df, storage_names):
    # 1. è®¡ç®—æ ¸å¿ƒæŒ‡æ ‡
    total_cost = {
        'SMES': df['smes_power'].abs().sum() * BaseParams.SAMPLING_TIME / 3600 * 65,
        'è¶…çº§ç”µå®¹': df['sc_power'].abs().sum() * BaseParams.SAMPLING_TIME / 3600 * 2.0,
        'é£è½®': df['fess_power'].abs().sum() * BaseParams.SAMPLING_TIME / 3600 * 10.0,
        'é”‚ç”µ': df['bess_power'].abs().sum() * BaseParams.SAMPLING_TIME / 3600 * 0.7,
        'å‹ç¼©ç©ºæ°”': df['caes_power'].abs().sum() * BaseParams.SAMPLING_TIME / 3600 * 2.75 +
                  df['caes_power'].clip(lower=0).sum() * BaseParams.SAMPLING_TIME / 3600 * 3.6 * 0.1  # å¤©ç„¶æ°”æˆæœ¬
    }
    total_cost_sum = sum(total_cost.values())
    power_ratio = {
        'SMES': df['smes_power'].abs().sum() / df[['smes_power', 'sc_power', 'fess_power', 'bess_power', 'caes_power']].abs().sum().sum(),
        'è¶…çº§ç”µå®¹': df['sc_power'].abs().sum() / df[['smes_power', 'sc_power', 'fess_power', 'bess_power', 'caes_power']].abs().sum().sum(),
        'é£è½®': df['fess_power'].abs().sum() / df[['smes_power', 'sc_power', 'fess_power', 'bess_power', 'caes_power']].abs().sum().sum(),
        'é”‚ç”µ': df['bess_power'].abs().sum() / df[['smes_power', 'sc_power', 'fess_power', 'bess_power', 'caes_power']].abs().sum().sum(),
        'å‹ç¼©ç©ºæ°”': df['caes_power'].abs().sum() / df[['smes_power', 'sc_power', 'fess_power', 'bess_power', 'caes_power']].abs().sum().sum()
    }

    # è¾“å‡ºæ ¸å¿ƒæ•°æ®
    print("="*50)
    print("ğŸ“Š æ ¸å¿ƒè¾“å‡ºæ•°æ®")
    print("="*50)
    print(f"æ€»è¿è¡Œæˆæœ¬ï¼š{total_cost_sum:.2f} å…ƒ")
    print("\nå„å‚¨èƒ½æˆæœ¬æ˜ç»†ï¼š")
    for name, cost in total_cost.items():
        print(f"  {name}ï¼š{cost:.2f} å…ƒ")
    print("\nå„å‚¨èƒ½åŠŸç‡å æ¯”ï¼š")
    for name, ratio in power_ratio.items():
        print(f"  {name}ï¼š{ratio:.2%}")
    print("\nå„å‚¨èƒ½æœ€ç»ˆå‰©ä½™ç”µé‡ï¼š")
    print(f"  SMESï¼š{df['smes_energy'].iloc[-1]:.2f} kWh")
    print(f"  è¶…çº§ç”µå®¹ï¼š{df['sc_energy'].iloc[-1]:.2f} kWh")
    print(f"  é£è½®ï¼š{df['fess_energy'].iloc[-1]:.2f} kWh")
    print(f"  é”‚ç”µï¼š{df['bess_energy'].iloc[-1]:.2f} kWh")
    print(f"  å‹ç¼©ç©ºæ°”ï¼š{df['caes_energy'].iloc[-1]:.2f} kWh")
    print(f"\nè„‰å†²æŠ¹å¹³æ•ˆæœï¼š")
    print(f"  åŸå§‹è´Ÿè·æ³¢åŠ¨èŒƒå›´ï¼š{df['total_load'].min():.2f}~{df['total_load'].max():.2f} kW")
    print(f"  æŠ¹å¹³åè´Ÿè·æ³¢åŠ¨èŒƒå›´ï¼š{df['smoothed_load'].min():.2f}~{df['smoothed_load'].max():.2f} kW")
    print(f"  æ³¢åŠ¨æ¶ˆé™¤ç‡ï¼š{1 - (df['smoothed_load'].max() - df['smoothed_load'].min())/(df['total_load'].max() - df['total_load'].min()):.2%}")

    # 2. ç»˜åˆ¶å¯è§†åŒ–å›¾è¡¨
    fig, axes = plt.subplots(4, 1, figsize=(15, 12))
    fig.suptitle('äº”å‚¨èƒ½æ··åˆååŒè°ƒåº¦ä»¿çœŸç»“æœ', fontsize=16, fontweight='bold')

    # å­å›¾1ï¼šè´Ÿè·ä¸æŠ¹å¹³æ•ˆæœ
    axes[0].plot(df['time'], df['total_load']/1e3, label='åŸå§‹æ€»è´Ÿè·', color='red', alpha=0.6, linewidth=2)
    axes[0].plot(df['time'], df['smoothed_load']/1e3, label='æŠ¹å¹³åè´Ÿè·', color='green', linewidth=2.5)
    axes[0].axhline(y=BaseParams.PLANT_POWER/1e3, color='blue', linestyle='--', label='ç”µå‚è¾“å‡ºåŠŸç‡')
    axes[0].set_xlabel('æ—¶é—´ï¼ˆsï¼‰')
    axes[0].set_ylabel('åŠŸç‡ï¼ˆMWï¼‰')
    axes[0].set_title('è„‰å†²è´Ÿè·æŠ¹å¹³æ•ˆæœ')
    axes[0].legend()
    axes[0].grid(True, alpha=0.3)

    # å­å›¾2ï¼šå„å‚¨èƒ½å‡ºåŠ›
    axes[1].plot(df['time'], df['smes_power']/1e3, label='SMES', linewidth=2)
    axes[1].plot(df['time'], df['sc_power']/1e3, label='è¶…çº§ç”µå®¹', linewidth=2)
    axes[1].plot(df['time'], df['fess_power']/1e3, label='é£è½®', linewidth=2)
    axes[1].plot(df['time'], df['bess_power']/1e3, label='é”‚ç”µ', linewidth=2)
    axes[1].plot(df['time'], df['caes_power']/1e3, label='å‹ç¼©ç©ºæ°”', linewidth=2)
    axes[1].set_xlabel('æ—¶é—´ï¼ˆsï¼‰')
    axes[1].set_ylabel('åŠŸç‡ï¼ˆMWï¼‰')
    axes[1].set_title('å„å‚¨èƒ½å®æ—¶å‡ºåŠ›')
    axes[1].legend()
    axes[1].grid(True, alpha=0.3)

    # å­å›¾3ï¼šå„å‚¨èƒ½å‰©ä½™ç”µé‡
    axes[2].plot(df['time'], df['smes_energy'], label='SMES', linewidth=2)
    axes[2].plot(df['time'], df['sc_energy'], label='è¶…çº§ç”µå®¹', linewidth=2)
    axes[2].plot(df['time'], df['fess_energy'], label='é£è½®', linewidth=2)
    axes[2].plot(df['time'], df['bess_energy'], label='é”‚ç”µ', linewidth=2)
    axes[2].plot(df['time'], df['caes_energy'], label='å‹ç¼©ç©ºæ°”', linewidth=2)
    axes[2].set_xlabel('æ—¶é—´ï¼ˆsï¼‰')
    axes[2].set_ylabel('å‰©ä½™ç”µé‡ï¼ˆkWhï¼‰')
    axes[2].set_title('å„å‚¨èƒ½å‰©ä½™ç”µé‡å˜åŒ–')
    axes[2].legend()
    axes[2].grid(True, alpha=0.3)

    # å­å›¾4ï¼šå‚¨èƒ½åŠŸç‡å æ¯”é¥¼å›¾
    axes[3].pie(power_ratio.values(), labels=power_ratio.keys(), autopct='%1.1f%%', startangle=90)
    axes[3].set_title('å„å‚¨èƒ½åŠŸç‡å æ¯”')

    plt.tight_layout()
    plt.show()

    # ç»˜åˆ¶ç”µæµç”µå‹å˜åŒ–å›¾
    fig, axes = plt.subplots(2, 1, figsize=(15, 8))
    fig.suptitle('å„å‚¨èƒ½ç”µæµç”µå‹å˜åŒ–', fontsize=16, fontweight='bold')

    # ç”µæµå˜åŒ–
    axes[0].plot(df['time'], df['smes_current'], label='SMES', linewidth=2)
    axes[0].plot(df['time'], df['sc_current'], label='è¶…çº§ç”µå®¹', linewidth=2)
    axes[0].plot(df['time'], df['fess_current'], label='é£è½®', linewidth=2)
    axes[0].plot(df['time'], df['bess_current'], label='é”‚ç”µ', linewidth=2)
    axes[0].plot(df['time'], df['caes_current'], label='å‹ç¼©ç©ºæ°”', linewidth=2)
    axes[0].set_xlabel('æ—¶é—´ï¼ˆsï¼‰')
    axes[0].set_ylabel('ç”µæµï¼ˆAï¼‰')
    axes[0].set_title('å®æ—¶ç”µæµå˜åŒ–')
    axes[0].legend()
    axes[0].grid(True, alpha=0.3)

    # ç”µå‹å˜åŒ–
    axes[1].plot(df['time'], df['smes_voltage'], label='SMES', linewidth=2)
    axes[1].plot(df['time'], df['sc_voltage'], label='è¶…çº§ç”µå®¹', linewidth=2)
    axes[1].plot(df['time'], df['fess_voltage'], label='é£è½®', linewidth=2)
    axes[1].plot(df['time'], df['bess_voltage'], label='é”‚ç”µ', linewidth=2)
    axes[1].plot(df['time'], df['caes_voltage'], label='å‹ç¼©ç©ºæ°”', linewidth=2)
    axes[1].set_xlabel('æ—¶é—´ï¼ˆsï¼‰')
    axes[1].set_ylabel('ç”µå‹ï¼ˆVï¼‰')
    axes[1].set_title('å®æ—¶ç”µå‹å˜åŒ–')
    axes[1].legend()
    axes[1].grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

# ============================ 6. ä¸»ç¨‹åºæ‰§è¡Œ ============================
if __name__ == "__main__":
    # è¿è¡Œä»¿çœŸ
    df_result, storage_names = simulate_system()
    # åˆ†æç»“æœå¹¶ç»˜å›¾
    analyze_results(df_result, storage_names)
