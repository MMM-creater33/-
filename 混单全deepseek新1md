import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from scipy import signal, fft
from scipy.optimize import minimize
import pandas as pd
import warnings

warnings.filterwarnings('ignore')

plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False


# ==================== 价格参数配置（南京冬季工商业） ====================
class EnergyPrices:
    """能源价格配置类"""

    def __init__(self):
        # 电力价格（元/kWh）- 南京冬季工商业分时电价
        self.electricity_prices = {
            'valley': 0.21,  # 低谷期: 00:00-06:00, 11:00-13:00
            'flat': 0.62,  # 平段: 06:00-11:00, 13:00-14:00, 22:00-24:00
            'peak': 1.12,  # 高峰期: 14:00-22:00
            'super_peak': 1.34  # 尖峰期: 18:00-20:00 (大工业)
        }

        # 天然气价格（元/立方米）
        self.gas_price = 3.65  # 南京冬季工商业天然气参考价

        # 设备成本（CAPEX）- 单位成本
        self.capex = {
            'BESS': 0.70,  # 元/Wh (磷酸铁锂系统)
            'SC': 2.00,  # 元/Wh (超级电容)
            'FESS': 10000,  # 元/kW (飞轮)
            'SMES': 65000,  # 元/kWh (超导磁储能)
            'CAES': 2750  # 元/kWh (压缩空气)
        }

        # 运维成本（OPEX）- 元/kWh/年
        self.opex = {
            'BESS': 25,
            'SC': 15,
            'FESS': 30,
            'SMES': 5000,  # 超导维护成本极高
            'CAES': 10
        }

        # 效率参数
        self.efficiencies = {
            'BESS': 0.92,
            'SC': 0.95,
            'FESS': 0.90,
            'SMES': 0.97,
            'CAES': 0.65
        }


# ==================== 储能单元基类 ====================
class EnergyStorageUnit:
    """储能单元基类"""

    def __init__(self, name, capacity_kwh, power_kw, efficiency=0.9,
                 capex_cost=0, opex_cost=0):
        self.name = name
        self.capacity_kwh = capacity_kwh  # 容量 (kWh)
        self.power_kw = power_kw  # 功率 (kW)
        self.max_power_kw = power_kw  # 最大功率
        self.efficiency = efficiency  # 往返效率
        self.capex_cost = capex_cost  # 投资成本
        self.opex_cost = opex_cost  # 运维成本

        # 状态变量
        self.soc = 0.5  # 荷电状态 (0-1)
        self.current_a = 0  # 电流 (A)
        self.voltage_v = 0  # 电压 (V)
        self.energy_kwh = capacity_kwh * 0.5  # 当前能量 (kWh)
        self.temperature_k = 298  # 温度 (K)

        # 历史记录（统一长度管理）
        self.cost_history = []  # 成本记录
        self.power_history = []  # 功率记录
        self.soc_history = []  # SOC记录
        self.current_history = []  # 电流记录
        self.voltage_history = []  # 电压记录
        self.energy_history = []  # 能量记录

    def _record_state(self, power_kw=None):
        """记录当前状态"""
        self.soc_history.append(self.soc)
        self.current_history.append(self.current_a)
        self.voltage_history.append(self.voltage_v)
        self.energy_history.append(self.energy_kwh)

        if power_kw is not None:
            self.power_history.append(power_kw)

    def charge(self, power_kw, duration_s):
        """充电操作"""
        # 计算实际可充电功率（考虑功率限制）
        actual_power = min(power_kw, self.power_kw)

        # 计算充电能量（考虑效率）
        energy_input_kwh = actual_power * duration_s / 3600
        energy_stored_kwh = energy_input_kwh * self.efficiency ** 0.5

        # 更新能量状态
        self.energy_kwh = min(self.capacity_kwh,
                              self.energy_kwh + energy_stored_kwh)
        self.soc = self.energy_kwh / self.capacity_kwh

        # 计算电流电压（简化模型）
        self.voltage_v = 400 + (self.soc - 0.5) * 100  # 简化电压模型
        self.current_a = actual_power * 1000 / self.voltage_v if self.voltage_v > 0 else 0

        # 记录状态
        self._record_state(actual_power)

        return actual_power, energy_input_kwh

    def discharge(self, power_kw, duration_s):
        """放电操作"""
        # 计算最大可放电功率
        max_discharge_power = min(power_kw, self.power_kw,
                                  self.energy_kwh * 3600 / duration_s)

        if max_discharge_power <= 0:
            self._record_state(0)
            return 0, 0

        # 计算放电能量（考虑效率）
        energy_output_kwh = max_discharge_power * duration_s / 3600
        energy_used_kwh = energy_output_kwh / self.efficiency ** 0.5

        # 更新能量状态
        self.energy_kwh = max(0, self.energy_kwh - energy_used_kwh)
        self.soc = self.energy_kwh / self.capacity_kwh

        # 计算电流电压
        self.voltage_v = 400 + (self.soc - 0.5) * 100
        self.current_a = max_discharge_power * 1000 / self.voltage_v if self.voltage_v > 0 else 0

        # 记录状态
        self._record_state(-max_discharge_power)

        return max_discharge_power, energy_output_kwh

    def idle(self):
        """空闲状态，只记录不充放电"""
        self._record_state(0)

    def calculate_cost(self, energy_kwh, is_charging=True, electricity_price=0.62):
        """计算能量成本"""
        if is_charging:
            # 充电成本
            energy_cost = energy_kwh * electricity_price
            opex_cost = energy_kwh * self.opex_cost / 365 / 24
        else:
            # 放电收益（负成本）
            energy_cost = -energy_kwh * electricity_price
            opex_cost = energy_kwh * self.opex_cost / 365 / 24

        total_cost = energy_cost + opex_cost
        self.cost_history.append(total_cost)

        return total_cost

    def get_status(self):
        """获取当前状态"""
        return {
            'name': self.name,
            'soc': self.soc,
            'energy_kwh': self.energy_kwh,
            'power_kw': self.power_history[-1] if self.power_history else 0,
            'current_a': self.current_a,
            'voltage_v': self.voltage_v,
            'temperature_k': self.temperature_k,
            'available_energy_kwh': self.energy_kwh,
            'available_power_kw': min(self.power_kw,
                                      self.energy_kwh * 3600 / 1)  # 1秒内可释放功率
        }


# ==================== 具体储能设备类 ====================
class BESS(EnergyStorageUnit):
    """电池储能系统"""

    def __init__(self, capacity_kwh, power_kw, prices):
        capex = capacity_kwh * 1000 * prices.capex['BESS']  # 转换为Wh
        opex = prices.opex['BESS']
        super().__init__('BESS', capacity_kwh, power_kw,
                         prices.efficiencies['BESS'], capex, opex)


class SC(EnergyStorageUnit):
    """超级电容器"""

    def __init__(self, capacity_kwh, power_kw, prices):
        capex = capacity_kwh * 1000 * prices.capex['SC']
        opex = prices.opex['SC']
        super().__init__('SC', capacity_kwh, power_kw,
                         prices.efficiencies['SC'], capex, opex)


class FESS(EnergyStorageUnit):
    """飞轮储能"""

    def __init__(self, capacity_kwh, power_kw, prices):
        capex = power_kw * prices.capex['FESS']
        opex = prices.opex['FESS']
        super().__init__('FESS', capacity_kwh, power_kw,
                         prices.efficiencies['FESS'], capex, opex)


class SMES(EnergyStorageUnit):
    """超导磁储能"""

    def __init__(self, capacity_kwh, power_kw, prices):
        capex = capacity_kwh * prices.capex['SMES']
        opex = prices.opex['SMES']
        super().__init__('SMES', capacity_kwh, power_kw,
                         prices.efficiencies['SMES'], capex, opex)


class CAES(EnergyStorageUnit):
    """压缩空气储能"""

    def __init__(self, capacity_kwh, power_kw, prices):
        capex = capacity_kwh * prices.capex['CAES']
        opex = prices.opex['CAES']
        super().__init__('CAES', capacity_kwh, power_kw,
                         prices.efficiencies['CAES'], capex, opex)

    def discharge(self, power_kw, duration_s, gas_price):
        """CAES放电需要消耗天然气"""
        power_output, energy_output = super().discharge(power_kw, duration_s)

        # 计算天然气消耗（简化模型）
        gas_consumption = energy_output * 0.3  # 每kWh电力消耗0.3元天然气
        gas_cost = gas_consumption * gas_price

        # 记录额外成本
        self.cost_history[-1] += gas_cost

        return power_output, energy_output, gas_cost


# ==================== 频率分解工具（替代小波包） ====================
class FrequencyDecomposer:
    """频率分解工具，用于功率频段分解"""

    def __init__(self, sampling_freq=10):
        self.sampling_freq = sampling_freq  # 采样频率 (Hz)

    def moving_average_decomposition(self, signal_data, window_sizes=[10, 5, 2]):
        """使用移动平均进行多尺度分解"""
        if len(signal_data) == 0:
            return {}

        decomposed = {}

        # 最低频（最平滑）
        if len(signal_data) >= window_sizes[0]:
            decomposed['ultra_low'] = np.convolve(signal_data,
                                                  np.ones(window_sizes[0]) / window_sizes[0],
                                                  mode='same')[:len(signal_data)]
        else:
            decomposed['ultra_low'] = np.mean(signal_data) * np.ones_like(signal_data)

        # 低频
        if len(signal_data) >= window_sizes[1]:
            decomposed['low'] = np.convolve(signal_data,
                                            np.ones(window_sizes[1]) / window_sizes[1],
                                            mode='same')[:len(signal_data)]
        else:
            decomposed['low'] = signal_data

        # 中频（原始信号减去低频）
        decomposed['medium'] = signal_data - decomposed['low']

        # 高频（原始信号减去所有低频成分）
        if len(signal_data) >= window_sizes[2]:
            high_freq = np.convolve(decomposed['medium'],
                                    np.ones(window_sizes[2]) / window_sizes[2],
                                    mode='same')[:len(signal_data)]
            decomposed['high'] = decomposed['medium'] - high_freq
            decomposed['ultra_high'] = high_freq
        else:
            decomposed['high'] = decomposed['medium']
            decomposed['ultra_high'] = np.zeros_like(signal_data)

        return decomposed


# ==================== MPC控制器 ====================
class HierarchicalMPCController:
    """分层MPC控制器"""

    def __init__(self, storage_units, prices, total_power_mw=20, total_capacity_mwh=400):
        self.storage_units = storage_units
        self.prices = prices
        self.total_power_mw = total_power_mw * 1000  # 转换为kW
        self.total_capacity_mwh = total_capacity_mwh

        # 分配比例（根据频段特性优化）
        self.allocation_ratios = {
            'BESS': 0.30,  # 中低频，能量型
            'SC': 0.15,  # 高频，功率型
            'FESS': 0.20,  # 中高频，功率型
            'SMES': 0.05,  # 超高频，瞬时响应
            'CAES': 0.30  # 低频，能量型
        }

        # 频段分配映射
        self.frequency_mapping = {
            'ultra_low': ['CAES', 'BESS'],  # < 0.1 Hz
            'low': ['BESS', 'CAES'],  # 0.1-1 Hz
            'medium': ['FESS', 'BESS'],  # 1-10 Hz
            'high': ['SC', 'FESS'],  # 10-100 Hz
            'ultra_high': ['SMES', 'SC']  # > 100 Hz
        }

        # 初始化频率分解器
        self.decomposer = FrequencyDecomposer(sampling_freq=10)  # 10Hz采样

        # 历史数据记录
        self.load_history = []
        self.smoothed_history = []
        self.imbalance_history = []
        self.cost_history = []
        self.allocation_history = []

    def economic_layer(self, load_forecast, time_hours, prediction_horizon=24):
        """上层经济调度层"""
        # 简化经济调度：基于电价进行充放电优化
        optimized_schedule = []

        for t in range(min(prediction_horizon, len(load_forecast))):
            hour = (time_hours + t) % 24

            # 确定当前电价时段
            if hour in range(0, 6) or hour in range(11, 13):
                price = self.prices.electricity_prices['valley']
                action = 'charge'  # 低谷充电
            elif hour in range(14, 22):
                price = self.prices.electricity_prices['peak']
                if hour in range(18, 20):
                    price = self.prices.electricity_prices['super_peak']
                action = 'discharge'  # 高峰放电
            else:
                price = self.prices.electricity_prices['flat']
                action = 'idle'  # 平段空闲或微调

            optimized_schedule.append({
                'time': hour,
                'price': price,
                'action': action,
                'target_power': 0  # 由下层确定具体功率
            })

        return optimized_schedule

    def realtime_balance_layer(self, actual_load_kw, reference_power_kw, time_s):
        """下层实时平衡层"""
        # 计算不平衡功率
        imbalance_power = actual_load_kw - reference_power_kw

        # 记录历史数据
        self.load_history.append(actual_load_kw)
        self.smoothed_history.append(reference_power_kw)
        self.imbalance_history.append(imbalance_power)

        # 频率分解（使用移动平均方法）
        if len(self.imbalance_history) >= 8:  # 需要足够的数据点
            imbalance_series = np.array(self.imbalance_history[-8:])
            decomposed = self.decomposer.moving_average_decomposition(imbalance_series)

            # 分配不同频段给不同储能设备
            allocation = self._allocate_power_by_frequency(decomposed, imbalance_power)
        else:
            # 初始阶段使用简单分配
            allocation = self._simple_allocation(imbalance_power)

        # 执行功率分配
        total_power_allocated = 0
        total_cost = 0
        allocation_details = {}

        for unit_name, power_kw in allocation.items():
            unit = next((u for u in self.storage_units if u.name == unit_name), None)
            if not unit:
                continue

            if power_kw > 0:
                # 放电
                if unit_name == 'CAES':
                    power_out, energy_out, gas_cost = unit.discharge(
                        abs(power_kw), 1, self.prices.gas_price
                    )
                    cost = unit.calculate_cost(energy_out, is_charging=False,
                                               electricity_price=self._get_current_price(time_s))
                    cost += gas_cost
                else:
                    power_out, energy_out = unit.discharge(abs(power_kw), 1)
                    cost = unit.calculate_cost(energy_out, is_charging=False,
                                               electricity_price=self._get_current_price(time_s))
                total_power_allocated += power_out
            elif power_kw < 0:
                # 充电
                power_in, energy_in = unit.charge(abs(power_kw), 1)
                cost = unit.calculate_cost(energy_in, is_charging=True,
                                           electricity_price=self._get_current_price(time_s))
                total_power_allocated -= power_in
            else:
                # 空闲状态
                unit.idle()
                cost = 0

            total_cost += cost
            allocation_details[unit_name] = {
                'power_kw': power_kw,
                'actual_power': power_out if power_kw > 0 else -power_in if power_kw < 0 else 0,
                'soc': unit.soc,
                'cost': cost
            }

        # 确保所有设备都有记录（即使没有分配功率）
        for unit in self.storage_units:
            if unit.name not in allocation:
                unit.idle()

        self.cost_history.append(total_cost)
        self.allocation_history.append(allocation_details)

        return allocation_details, total_power_allocated, total_cost

    def _allocate_power_by_frequency(self, decomposed_power, total_imbalance):
        """根据频段分配功率"""
        allocation = {unit.name: 0 for unit in self.storage_units}

        if not decomposed_power:
            return self._simple_allocation(total_imbalance)

        # 分配各频段功率
        frequency_allocations = {
            'ultra_low': total_imbalance * 0.3,  # 30% 超低频
            'low': total_imbalance * 0.2,  # 20% 低频
            'medium': total_imbalance * 0.2,  # 20% 中频
            'high': total_imbalance * 0.2,  # 20% 高频
            'ultra_high': total_imbalance * 0.1  # 10% 超高频
        }

        # 根据频段映射分配到具体设备
        for freq, power in frequency_allocations.items():
            devices = self.frequency_mapping.get(freq, [])
            if devices:
                # 按比例分配到设备
                for i, device in enumerate(devices):
                    allocation[device] += power * (0.7 if i == 0 else 0.3)

        return allocation

    def _simple_allocation(self, imbalance_power):
        """简单功率分配策略"""
        allocation = {}

        # 根据SOC状态和功率能力动态调整
        total_available = sum(u.power_kw for u in self.storage_units)

        for unit in self.storage_units:
            # 考虑SOC平衡
            soc_factor = 1 - abs(unit.soc - 0.5)
            power_factor = unit.power_kw / total_available if total_available > 0 else 0

            # 综合权重
            weight = soc_factor * power_factor

            # 分配功率
            allocation[unit.name] = imbalance_power * weight

        return allocation

    def _get_current_price(self, time_s):
        """获取当前电价"""
        hour = (time_s // 3600) % 24

        if hour in range(0, 6) or hour in range(11, 13):
            return self.prices.electricity_prices['valley']
        elif hour in range(14, 22):
            if hour in range(18, 20):
                return self.prices.electricity_prices['super_peak']
            return self.prices.electricity_prices['peak']
        else:
            return self.prices.electricity_prices['flat']

    def calculate_pwm_strategy(self, pulse_start, pulse_duration, pulse_amplitude):
        """PWM脉宽调制策略生成"""
        pwm_period = 1.0  # PWM周期 (s)
        pwm_frequency = 1 / pwm_period

        # 生成PWM信号
        time_points = np.arange(0, pulse_duration, 0.01)
        duty_cycle = pulse_amplitude / self.total_power_mw

        pwm_signal = signal.square(2 * np.pi * pwm_frequency * time_points,
                                   duty=duty_cycle)
        pwm_signal = np.where(pwm_signal > 0, pulse_amplitude, 0)

        return time_points, pwm_signal


# ==================== 主仿真系统 ====================
class HESSSimulation:
    """混合储能系统主仿真"""

    def __init__(self):
        # 初始化价格配置
        self.prices = EnergyPrices()

        # 系统参数（根据图片修正）
        self.total_power_mw = 20  # 总功率 20MW
        self.total_capacity_mwh = 400  # 总容量 400MWh（根据图片修正）
        self.power_plant_mw = 13  # 电厂出力 13MW
        self.base_load_mw = 10  # 基本负荷 10MW
        self.pulse_amplitude_mw = 18  # 脉冲幅度 18MW
        self.pulse_duration_s = 10  # 脉冲持续时间 10s
        self.max_pulse_mw = 20  # 最大脉冲 20MW
        self.max_pulse_duration_s = 20  # 最大脉冲持续时间 20s

        # 分配容量和功率（根据优化比例）
        self._initialize_storage_units()

        # 初始化MPC控制器
        self.controller = HierarchicalMPCController(
            self.storage_units, self.prices,
            self.total_power_mw, self.total_capacity_mwh
        )

        # 仿真时间参数
        self.simulation_duration_s = 60  # 仿真时长 60秒
        self.time_step_s = 0.1  # 时间步长 0.1秒

        # 数据记录
        self.results = {
            'time': [],
            'load': [],
            'smoothed': [],
            'imbalance': [],
            'costs': [],
            'allocations': [],
            'status': []
        }

    def _initialize_storage_units(self):
        """初始化储能单元"""
        # 分配功率（根据技术特性）
        power_allocation = {
            'BESS': self.total_power_mw * 0.30 * 1000,  # 30% = 6MW
            'SC': self.total_power_mw * 0.15 * 1000,  # 15% = 3MW
            'FESS': self.total_power_mw * 0.20 * 1000,  # 20% = 4MW
            'SMES': self.total_power_mw * 0.05 * 1000,  # 5% = 1MW
            'CAES': self.total_power_mw * 0.30 * 1000  # 30% = 6MW
        }

        # 分配容量（根据能量密度特性）
        capacity_allocation = {
            'BESS': self.total_capacity_mwh * 0.25,  # 25% = 100MWh
            'SC': self.total_capacity_mwh * 0.05,  # 5% = 20MWh
            'FESS': self.total_capacity_mwh * 0.10,  # 10% = 40MWh
            'SMES': self.total_capacity_mwh * 0.05,  # 5% = 20MWh
            'CAES': self.total_capacity_mwh * 0.55  # 55% = 220MWh
        }

        # 创建储能单元实例
        self.storage_units = [
            BESS(capacity_allocation['BESS'], power_allocation['BESS'], self.prices),
            SC(capacity_allocation['SC'], power_allocation['SC'], self.prices),
            FESS(capacity_allocation['FESS'], power_allocation['FESS'], self.prices),
            SMES(capacity_allocation['SMES'], power_allocation['SMES'], self.prices),
            CAES(capacity_allocation['CAES'], power_allocation['CAES'], self.prices)
        ]

    def generate_load_profile(self):
        """生成负荷曲线（含脉冲）"""
        time_points = np.arange(0, self.simulation_duration_s, self.time_step_s)
        num_points = len(time_points)
        load_profile = np.ones(num_points) * self.base_load_mw * 1000  # 转换为kW

        # 添加脉冲
        pulse_start = 20  # 第20秒开始
        pulse_end = pulse_start + self.pulse_duration_s

        # 创建脉冲（考虑上升和下降沿）
        for i, t in enumerate(time_points):
            if pulse_start <= t < pulse_end:
                # 脉冲形状（考虑实际上升时间）
                if t - pulse_start < 0.5:  # 0.5秒上升沿
                    factor = (t - pulse_start) / 0.5
                elif pulse_end - t < 0.5:  # 0.5秒下降沿
                    factor = (pulse_end - t) / 0.5
                else:
                    factor = 1.0

                load_profile[i] += self.pulse_amplitude_mw * 1000 * factor

        return time_points, load_profile

    def run_simulation(self):
        """运行主仿真"""
        print("开始混合储能系统仿真...")
        print(f"系统配置: 总功率 {self.total_power_mw}MW, 总容量 {self.total_capacity_mwh}MWh")
        print(f"电厂出力: {self.power_plant_mw}MW, 基本负荷: {self.base_load_mw}MW")
        print(f"脉冲负荷: {self.pulse_amplitude_mw}MW 持续 {self.pulse_duration_s}秒")
        print("=" * 60)

        # 生成负荷曲线
        time_points, load_profile = self.generate_load_profile()

        # 初始经济调度
        economic_schedule = self.controller.economic_layer(
            load_profile / 1000, 0, prediction_horizon=24
        )

        # 实时控制循环
        for idx, t in enumerate(time_points):
            # 当前负荷
            current_load = load_profile[idx]

            # 目标平滑功率（电厂出力）
            target_power = self.power_plant_mw * 1000  # kW

            # 执行实时平衡
            allocation, total_allocated, cost = self.controller.realtime_balance_layer(
                current_load, target_power, t
            )

            # 记录结果
            self.results['time'].append(t)
            self.results['load'].append(current_load)
            self.results['smoothed'].append(target_power)
            self.results['imbalance'].append(current_load - target_power)
            self.results['costs'].append(cost)
            self.results['allocations'].append(allocation)

            # 记录设备状态（从设备历史记录中获取最新状态）
            status = {}
            for unit in self.storage_units:
                if len(unit.soc_history) > idx:
                    status[unit.name] = {
                        'soc': unit.soc_history[idx],
                        'energy_kwh': unit.energy_history[idx] if len(unit.energy_history) > idx else unit.energy_kwh,
                        'current_a': unit.current_history[idx] if len(unit.current_history) > idx else unit.current_a,
                        'voltage_v': unit.voltage_history[idx] if len(unit.voltage_history) > idx else unit.voltage_v,
                        'power_kw': unit.power_history[idx] if len(unit.power_history) > idx else 0,
                        'name': unit.name
                    }
                else:
                    # 如果历史记录不够长，使用当前状态
                    status[unit.name] = unit.get_status()
            self.results['status'].append(status)

            # 进度显示
            if idx % 100 == 0:
                print(f"时间: {t:.1f}s, 负荷: {current_load / 1000:.1f}MW, "
                      f"平滑后: {target_power / 1000:.1f}MW, "
                      f"成本: {cost:.2f}元")

        print("仿真完成!")
        print("=" * 60)

    def calculate_performance_metrics(self):
        """计算性能指标"""
        load = np.array(self.results['load'])
        smoothed = np.array(self.results['smoothed'])
        imbalance = np.array(self.results['imbalance'])
        costs = np.array(self.results['costs'])

        # 平滑效果指标
        rmse = np.sqrt(np.mean(imbalance ** 2)) / 1000  # MW
        max_error = np.max(np.abs(imbalance)) / 1000  # MW

        # 成本指标
        total_cost = np.sum(costs)
        avg_cost_per_kwh = total_cost / (np.sum(np.abs(imbalance)) / 1000) if np.sum(np.abs(imbalance)) > 0 else 0

        # 储能利用率
        soc_values = []
        for status in self.results['status']:
            for unit_name, unit_status in status.items():
                soc_values.append(unit_status['soc'])

        avg_soc = np.mean(soc_values)
        soc_variance = np.var(soc_values)

        # 计算脉冲消除率
        if self.pulse_amplitude_mw > 0:
            pulse_elimination_rate = (1 - rmse / (self.pulse_amplitude_mw / 2)) * 100
        else:
            pulse_elimination_rate = 100

        metrics = {
            '平滑效果_RMSE_MW': rmse,
            '最大误差_MW': max_error,
            '总成本_元': total_cost,
            '平均成本_元_kWh': avg_cost_per_kwh,
            '平均SOC': avg_soc,
            'SOC方差': soc_variance,
            '脉冲消除率_%': pulse_elimination_rate
        }

        return metrics

    def plot_results(self):
        """绘制结果图表"""
        fig = plt.figure(figsize=(20, 16))
        gs = gridspec.GridSpec(4, 3, figure=fig)

        # 1. 原始负荷与平滑后负荷对比
        ax1 = fig.add_subplot(gs[0, :])
        time_array = np.array(self.results['time'])
        load_array = np.array(self.results['load']) / 1000
        smoothed_array = np.array(self.results['smoothed']) / 1000

        ax1.plot(time_array, load_array, 'r-', linewidth=2, label='原始负荷')
        ax1.plot(time_array, smoothed_array, 'b-', linewidth=2, label='平滑后负荷')
        ax1.fill_between(time_array, 10, 28, alpha=0.2, color='gray',
                         label='脉冲区域')
        ax1.set_xlabel('时间 (s)')
        ax1.set_ylabel('功率 (MW)')
        ax1.set_title('负荷平滑效果对比图')
        ax1.legend()
        ax1.grid(True, alpha=0.3)

        # 2. 各储能设备功率分配
        ax2 = fig.add_subplot(gs[1, :])

        # 提取各设备功率
        device_powers = {name: [] for name in ['BESS', 'SC', 'FESS', 'SMES', 'CAES']}
        for allocation in self.results['allocations']:
            for name in device_powers.keys():
                if name in allocation:
                    device_powers[name].append(allocation[name]['power_kw'] / 1000)
                else:
                    device_powers[name].append(0)

        # 确保长度一致
        min_len = min(len(time_array), len(device_powers['BESS']))
        time_plot = time_array[:min_len]

        bottom = np.zeros(min_len)
        colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']

        for idx, (name, power) in enumerate(device_powers.items()):
            power_plot = np.array(power[:min_len])
            ax2.fill_between(time_plot, bottom, bottom + power_plot,
                             label=name, alpha=0.7, color=colors[idx])
            bottom += power_plot

        ax2.set_xlabel('时间 (s)')
        ax2.set_ylabel('功率 (MW)')
        ax2.set_title('储能设备功率分配策略')
        ax2.legend()
        ax2.grid(True, alpha=0.3)

        # 3. SOC变化曲线
        ax3 = fig.add_subplot(gs[2, 0])

        # 从结果中提取SOC数据
        for unit_name in ['BESS', 'SC', 'FESS', 'SMES', 'CAES']:
            soc_data = []
            for status in self.results['status']:
                if unit_name in status:
                    soc_data.append(status[unit_name]['soc'])
                else:
                    soc_data.append(0.5)  # 默认值

            # 确保长度一致
            soc_plot = soc_data[:min_len]
            ax3.plot(time_plot, soc_plot, label=unit_name, linewidth=2)

        ax3.set_xlabel('时间 (s)')
        ax3.set_ylabel('SOC')
        ax3.set_title('各储能设备SOC变化')
        ax3.legend()
        ax3.grid(True, alpha=0.3)

        # 4. 成本累计曲线
        ax4 = fig.add_subplot(gs[2, 1])
        costs_array = np.array(self.results['costs'])
        if len(costs_array) > min_len:
            costs_array = costs_array[:min_len]
        cumulative_cost = np.cumsum(costs_array)
        ax4.plot(time_plot, cumulative_cost, 'g-', linewidth=2)
        ax4.set_xlabel('时间 (s)')
        ax4.set_ylabel('累计成本 (元)')
        ax4.set_title('运行成本累计')
        ax4.grid(True, alpha=0.3)

        # 5. 电流电压关系图
        ax5 = fig.add_subplot(gs[2, 2])

        # 从结果中提取电流电压数据
        for unit_name in ['BESS', 'SC', 'FESS', 'SMES', 'CAES']:
            currents = []
            voltages = []

            for status in self.results['status'][-100:]:  # 取最后100个点
                if unit_name in status:
                    currents.append(status[unit_name]['current_a'])
                    voltages.append(status[unit_name]['voltage_v'])

            if currents and voltages:
                ax5.scatter(currents, voltages, label=unit_name, alpha=0.6)

        ax5.set_xlabel('电流 (A)')
        ax5.set_ylabel('电压 (V)')
        ax5.set_title('电流-电压特性')
        ax5.legend()
        ax5.grid(True, alpha=0.3)

        # 6. 能量-电压关系图
        ax6 = fig.add_subplot(gs[3, 0])

        # 从结果中提取能量电压数据
        for unit_name in ['BESS', 'SC', 'FESS', 'SMES', 'CAES']:
            energies = []
            voltages = []

            for status in self.results['status']:
                if unit_name in status:
                    energies.append(status[unit_name]['energy_kwh'])
                    voltages.append(status[unit_name]['voltage_v'])

            if len(energies) > min_len:
                energies = energies[:min_len]
                voltages = voltages[:min_len]

            if energies and voltages:
                ax6.plot(energies, voltages, 'o-', label=unit_name, alpha=0.7, markersize=3)

        ax6.set_xlabel('能量 (kWh)')
        ax6.set_ylabel('电压 (V)')
        ax6.set_title('能量-电压关系')
        ax6.legend()
        ax6.grid(True, alpha=0.3)

        # 7. 脉冲功率分配饼图
        ax7 = fig.add_subplot(gs[3, 1])

        # 计算脉冲期间的平均分配
        pulse_indices = np.where((time_array >= 20) & (time_array <= 30))[0]

        pulse_allocation = {name: 0 for name in device_powers.keys()}
        for idx in pulse_indices:
            if idx < len(self.results['allocations']):
                allocation = self.results['allocations'][idx]
                for name in device_powers.keys():
                    if name in allocation:
                        pulse_allocation[name] += abs(allocation[name]['power_kw'])

        total_pulse_power = sum(pulse_allocation.values())
        if total_pulse_power > 0:
            percentages = {k: v / total_pulse_power * 100 for k, v in pulse_allocation.items()}
            ax7.pie(percentages.values(), labels=percentages.keys(),
                    autopct='%1.1f%%', colors=colors)
            ax7.set_title('脉冲功率分配占比')
        else:
            ax7.text(0.5, 0.5, '无脉冲功率分配数据',
                     horizontalalignment='center', verticalalignment='center')
            ax7.set_title('脉冲功率分配占比')

        # 8. 频段分配示意图
        ax8 = fig.add_subplot(gs[3, 2])
        frequencies = ['超低频', '低频', '中频', '高频', '超高频']
        devices_by_freq = ['CAES+BESS', 'BESS+CAES', 'FESS+BESS', 'SC+FESS', 'SMES+SC']

        y_pos = np.arange(len(frequencies))
        ax8.barh(y_pos, [0.3, 0.4, 0.5, 0.6, 0.7], color=colors[:len(frequencies)])
        ax8.set_yticks(y_pos)
        ax8.set_yticklabels(frequencies)
        ax8.set_xlabel('分配权重')
        ax8.set_title('频段-设备映射关系')

        # 添加设备标签
        for i, (freq, device) in enumerate(zip(frequencies, devices_by_freq)):
            ax8.text(0.05, i, device, va='center', color='white', fontweight='bold')

        plt.tight_layout()
        plt.savefig('HESS_Simulation_Results.png', dpi=300, bbox_inches='tight')
        plt.show()

    def print_detailed_report(self):
        """打印详细报告"""
        print("\n" + "=" * 60)
        print("混合储能系统仿真详细报告")
        print("=" * 60)

        # 系统配置
        print("\n1. 系统配置:")
        print(f"   总功率: {self.total_power_mw} MW")
        print(f"   总容量: {self.total_capacity_mwh} MWh")
        print(f"   电厂出力: {self.power_plant_mw} MW")
        print(f"   基本负荷: {self.base_load_mw} MW")
        print(f"   脉冲参数: {self.pulse_amplitude_mw} MW × {self.pulse_duration_s}s")

        # 储能设备详情
        print("\n2. 储能设备配置:")
        total_capex = 0
        for unit in self.storage_units:
            capex_million = unit.capex_cost / 1e6
            total_capex += unit.capex_cost
            print(f"   {unit.name}:")
            print(f"     容量: {unit.capacity_kwh / 1000:.1f} MWh")
            print(f"     功率: {unit.power_kw / 1000:.1f} MW")
            print(f"     效率: {unit.efficiency * 100:.1f}%")
            print(f"     投资成本: {capex_million:.2f} 百万元")
            print(f"     当前SOC: {unit.soc * 100:.1f}%")

        print(f"   总投资成本: {total_capex / 1e6:.2f} 百万元")

        # 分配策略
        print("\n3. 功率分配策略:")
        ratios = self.controller.allocation_ratios
        for device, ratio in ratios.items():
            print(f"   {device}: {ratio * 100:.1f}%")

        # 性能指标
        metrics = self.calculate_performance_metrics()
        print("\n4. 性能指标:")
        for key, value in metrics.items():
            print(f"   {key}: {value:.4f}")

        # 脉冲消除策略
        print("\n5. 脉冲消除策略:")
        print("   频段分解策略:")
        print("     超低频 (<0.1Hz): CAES + BESS 承担")
        print("     低频 (0.1-1Hz): BESS + CAES 承担")
        print("     中频 (1-10Hz): FESS + BESS 承担")
        print("     高频 (10-100Hz): SC + FESS 承担")
        print("     超高频 (>100Hz): SMES + SC 承担")

        print("\n   PWM控制策略:")
        print("     周期: 1.0s")
        print("     占空比: 根据脉冲幅度动态调整")
        print("     调制方式: 脉宽调制 + 频率调制")

        # 边界条件
        print("\n6. 系统边界条件:")
        print(f"   最大输入脉冲: {self.max_pulse_mw} MW")
        print(f"   最长脉冲持续时间: {self.max_pulse_duration_s} s")
        print(f"   最小响应时间: 1 ms (SMES)")
        print(f"   最大调节速率: 20 MW/s")
        print(f"   SOC安全范围: 20%-90%")

        # 经济效益
        print("\n7. 经济效益分析:")
        total_opex = sum(unit.opex_cost * unit.capacity_kwh for unit in self.storage_units)
        annual_cost = total_opex + total_capex / 10  # 10年折旧
        daily_cost = annual_cost / 365
        daily_savings = metrics['总成本_元']  # 仿真期间的成本（负值表示收益）

        print(f"   年运维成本: {total_opex / 1e6:.2f} 百万元")
        print(f"   年折旧成本: {total_capex / 10 / 1e6:.2f} 百万元")
        print(f"   日运行成本: {daily_cost / 1e3:.2f} 千元")
        print(f"   脉冲消除收益: {-daily_savings / 1e3:.2f} 千元/天")

        if -daily_savings > daily_cost:
            roi_years = total_capex / (-daily_savings * 365 - daily_cost * 365)
            print(f"   投资回收期: {roi_years:.1f} 年")
        else:
            print("   注: 当前配置下经济效益需进一步优化")

        print("\n" + "=" * 60)
        print("报告结束")
        print("=" * 60)


# ==================== 主程序 ====================
def main():
    """主函数"""
    print("混合储能系统（HESS）协同调度仿真程序")
    print("版本: 1.0 | 设计: 基于分层MPC的多元混合储能优化")
    print("=" * 60)

    # 创建仿真实例
    simulation = HESSSimulation()

    # 运行仿真
    simulation.run_simulation()

    # 打印详细报告
    simulation.print_detailed_report()

    # 绘制图表
    print("\n正在生成可视化图表...")
    simulation.plot_results()

    # 保存数据到CSV
    print("\n正在保存数据...")
    save_simulation_data(simulation)

    print("\n仿真程序执行完成!")
    print("图表已保存为: HESS_Simulation_Results.png")
    print("数据已保存为: HESS_Simulation_Data.csv")


def save_simulation_data(simulation):
    """保存仿真数据到CSV"""
    data = []

    # 确保所有数组长度一致
    min_len = min(
        len(simulation.results['time']),
        len(simulation.results['load']),
        len(simulation.results['smoothed']),
        len(simulation.results['imbalance']),
        len(simulation.results['costs'])
    )

    for i in range(min_len):
        row = {
            'time_s': simulation.results['time'][i],
            'load_kw': simulation.results['load'][i],
            'smoothed_kw': simulation.results['smoothed'][i],
            'imbalance_kw': simulation.results['imbalance'][i],
            'cost_yuan': simulation.results['costs'][i]
        }

        # 添加各设备状态
        for device_name in ['BESS', 'SC', 'FESS', 'SMES', 'CAES']:
            if device_name in simulation.results['status'][i]:
                status = simulation.results['status'][i][device_name]
                row[f'{device_name}_soc'] = status['soc']
                row[f'{device_name}_energy_kwh'] = status['energy_kwh']
                row[f'{device_name}_current_a'] = status['current_a']
                row[f'{device_name}_voltage_v'] = status['voltage_v']
                row[f'{device_name}_power_kw'] = status['power_kw']
            else:
                row[f'{device_name}_soc'] = 0
                row[f'{device_name}_energy_kwh'] = 0
                row[f'{device_name}_current_a'] = 0
                row[f'{device_name}_voltage_v'] = 0
                row[f'{device_name}_power_kw'] = 0

        data.append(row)

    df = pd.DataFrame(data)
    df.to_csv('HESS_Simulation_Data.csv', index=False, encoding='utf-8-sig')

    # 保存配置信息
    config = {
        'total_power_mw': simulation.total_power_mw,
        'total_capacity_mwh': simulation.total_capacity_mwh,
        'power_plant_mw': simulation.power_plant_mw,
        'base_load_mw': simulation.base_load_mw,
        'pulse_amplitude_mw': simulation.pulse_amplitude_mw,
        'pulse_duration_s': simulation.pulse_duration_s,
        'allocation_ratios': simulation.controller.allocation_ratios
    }

    config_df = pd.DataFrame([config])
    config_df.to_csv('HESS_Configuration.csv', index=False, encoding='utf-8-sig')


if __name__ == "__main__":
    main()
